import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as e,a as s}from"./app-e33eb8d4.js";const i={},d=s(`<h1 id="服务器运行数据查看工具" tabindex="-1"><a class="header-anchor" href="#服务器运行数据查看工具" aria-hidden="true">#</a> 服务器运行数据查看工具</h1><p>我们开发的软件服务需要在服务器上运行，所以服务器性能代表了软件的性能上限，因此服务器性能调优是个十分重要的环节，然而大部分同学对服务器性能调优关注的较少，今天从3个部分对服务器性能调优进行介绍，分别是：服务器配置选择，服务器负载分析，服务器内核参数调优。</p><h2 id="服务器配置选择" tabindex="-1"><a class="header-anchor" href="#服务器配置选择" aria-hidden="true">#</a> <strong>服务器配置选择</strong></h2><p>服务器一般是由CPU、内存、磁盘和网卡组成，因此选择服务器配置就是选择CPU核数、内存大小、磁盘大小及类型、网络带宽。但是，服务器配置的选择是很难标准化的，也就是说很难推断出“一台需要达到1000TPS的后端服务器”的配置应该是什么样的。因为软件的最终运行性能与软件的实现方式是紧密相关的，即使是同一个后端应用程序中的两个接口，由于具体功能的差别，性能也会有所差别。</p><p>因此，服务器配置的选择应该基于具体的测试结果。一开始可以选用配置较低的服务器做调优和测试，并以该服务器的测试结果作为选择服务器的依据。</p><p>以一个订单业务为例，经过测试后，一台配置为4核 CPU 、16GB内存、10Mbps带宽、50GB机械磁盘的服务器的测试结果为：支持50并发量和300TPS吞吐量（增大并发量后会出现超时报错）。而在压力测试过程中， CPU 的使用率接近75%，内存使用率在 50％以下，带宽使用率在50％以下，除去日志以外无磁盘操作。</p><p>因此可以认为，一台配置为4核 CPU ( CPU 使用率需要在75％以下）、8GB内存（内存使用率可以接近100%)、 5Mbps 带宽（带宽使用率可以接近100%）的服务器，可以满足订单接口支持50并发量、300TPS吞吐量的压力。</p><p>如果需要达到200并发数、2400TPS吞吐量的目标的话，则需要8台配置为4核 CPU 、8GB内存、5Mbps带宽的服务器，或者1台配置为32核 CPU 、64GB内存、40Mbps带宽的服务器。当然，最终的服务器配置还是需要通过测试来验证。</p><blockquote><p>注意：在以上订单接口的例子中，后端服务器和数据库等服务器需要一起调试，避免后端服务器性能过剩，而数据库等服务器性能不足的情况发生。另外，以上选择服务器配置的方法不一定适用于所有场景，请斟酌参考。</p></blockquote><h2 id="服务器负载分析" tabindex="-1"><a class="header-anchor" href="#服务器负载分析" aria-hidden="true">#</a> <strong>服务器负载分析</strong></h2><p>在性能调优时，需要先对服务器负载进行分析，通常而言，我们主要分析CPU使用率、内存使用率、磁盘I/O，服务器负载和带宽使用情况。</p><h3 id="cpu使用率" tabindex="-1"><a class="header-anchor" href="#cpu使用率" aria-hidden="true">#</a> CPU使用率</h3><p>CPU使用率反应的是CPU的忙碌情况。当CPU达到100%时，部分进程会进入等待状态，CPU暂时不会对其进行处理。<strong>在实际情况下，为了应对一下突发性的请求压力，服务器CPU使用率一般需要在75%以下。如果一台服务器的CPU使用率多次高于75%，这时候就考虑增加新的服务器。</strong></p><p>监控CPU使用率我推荐大家使用<strong>htop</strong>工具，可以非常直观看到CPU使用率、内存使用率、及负载等信息。</p><h4 id="使用htop查看cpu负载" tabindex="-1"><a class="header-anchor" href="#使用htop查看cpu负载" aria-hidden="true">#</a> 使用htop查看CPU负载</h4><p>首先我们需要安装htop，以centos为例，安装命令如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>yum <span class="token function">install</span> <span class="token function">htop</span> <span class="token parameter variable">-y</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>安装完成后我们就可以通过<code>htop</code>命令观察CPU负载了</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">htop</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>输入<code>htop</code>命令后我们可以很直观的看到CPU负载情况，该命令的CPU使用率会以多个核作为单位进行显示。操作系统机会自动分配多个核的负载，当所有核的CPU使用率都超过75%时才能认为服务器的CPU使用率已经超过75%。</p><p><img src="https://static.xlc520.tk/blogImage/640-16566648003660.png" alt="服务器运行数据查看工具" loading="lazy">cpu负载</p><p>如上图所示，这是一个4核CPU服务器，在截图的时候其中3核CPU使用率都超过了75%，再观察一会发现所有CPU的使用率都在85%左右徘徊，说明CPU负载很高了，需要考虑增加新的服务器。</p><h3 id="内存使用率" tabindex="-1"><a class="header-anchor" href="#内存使用率" aria-hidden="true">#</a> 内存使用率</h3><p>内存使用率反应的是内存的使用情况。内存用于存放程序的代码及数据，一般分为物理内存和虚拟内存，其中物理内存指的是服务器的内存，而虚拟内存指的是硬盘的一块空间。当物理内存使用率达到100%时将会使用虚拟内存。需要注意的是，虚拟内存的读写速度远远低于物理内存，如果程序被放在了虚拟内存执行，那么程序的执行效率会变得很低。</p><p><strong>一般而言，服务器的物理内存应该保持在80%以下，虚拟内存使用率保持在0%。</strong></p><p>服务器内存使用情况还是可以通过hop工具进行查看</p><p><img src="https://static.xlc520.tk/blogImage/640-16566648003661.png" alt="服务器运行数据查看工具" loading="lazy">内存使用率</p><p>上面显示了服务器的内存使用情况：总内存16G，使用了10G左右，内存使用率62%，可以继续使用，同时关闭了Swap虚拟内存。</p><p>在下<code>MEM%</code>栏中显示了单个进程的内存使用率。</p><h3 id="磁盘i-o" tabindex="-1"><a class="header-anchor" href="#磁盘i-o" aria-hidden="true">#</a> 磁盘I/O</h3><p>磁盘I/O指的是磁盘的读写，在软件系统中，日志、文件操作、数据库操作都会造成磁盘读写压力，其中又以数据库操作为甚，在高并发情况下往往数据库会首先成为系统的瓶颈。</p><p>磁盘监控我推荐大家使用iostat工具，可以很方便查看磁盘的使用情况。</p><h4 id="使用iostat查看磁盘i-o" tabindex="-1"><a class="header-anchor" href="#使用iostat查看磁盘i-o" aria-hidden="true">#</a> 使用iostat查看磁盘I/O</h4><p>首先我们需要安装<code>iostat</code>，以centos为例，安装命令如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>yum <span class="token function">install</span> sysstat <span class="token parameter variable">-y</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>安装完成后我们就可以通过<code>iostat</code>命令磁盘使用情况了。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 查看磁盘总体读写情况， 1代表每1秒读取一次数据</span>
iostat <span class="token parameter variable">-x</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://static.xlc520.tk/blogImage/640-16566648003662.png" alt="服务器运行数据查看工具" loading="lazy">磁盘IO</p><p>输入<code>iostat</code>命令后，磁盘总体读写情况如上所示。磁盘负载主要关注2个指标：<code>%idle</code>，<code>%util</code></p><ul><li><code>%idle</code>:表示CPU<strong>除去等待磁盘I/O以外</strong>的空闲时间百分比，这个指标应该要保证在70%以上</li><li><code>%util</code>:该设备用于I/O操作的时间百分比，这个指标需要保证在70%以下，当到达100%时表示已经满负载。为了降低磁盘负载，可以采用性能更高的磁盘（OSD，PCIE）或者降低磁盘的操作频率（异步写、合并写）</li></ul><h3 id="平均负载" tabindex="-1"><a class="header-anchor" href="#平均负载" aria-hidden="true">#</a> 平均负载</h3><p>平均负载指的是单位时间内平均的活跃进程数，是一个表示服务器负载的指标。一般情况下需要保证平均负载的值小于当前服务器的CPU核数。</p><p>同样的，查看服务器平均负载我们也可以使用<code>htop</code>命令</p><p><img src="https://static.xlc520.tk/blogImage/640-16566648003663.png" alt="服务器运行数据查看工具" loading="lazy">在这里我们主要关注<code>Load average</code>指标，上图有3个数字，分别代表1分钟，5分钟，15分钟的平均负载。</p><p>一般情况下服务器的平均负载需要小于当前服务器的CPU核数，为了应对突发状况，服务器的平均负载应该在75%即3 以下，很显然，上图这台服务器平均负载超过了75%，需要考虑提升性能了。</p><h3 id="网络使用情况" tabindex="-1"><a class="header-anchor" href="#网络使用情况" aria-hidden="true">#</a> 网络使用情况</h3><p>网络使用情况也是监控的重要指标。当带宽不足时会大大增加请求的响应时间。为了防止突发性并发压力，应该保证服务器的带宽使用率在80%以上。这里需要注意的是，物理网卡限制了服务器所能使用的最大宽带。</p><p>查看网络使用情况我推荐使用<code>nload</code>工具。</p><h4 id="使用nload查看网络" tabindex="-1"><a class="header-anchor" href="#使用nload查看网络" aria-hidden="true">#</a> 使用nload查看网络</h4><p>首先需要安装nload，以centos为例</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>yum <span class="token function">install</span> nload <span class="token parameter variable">-y</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>安装完成后我们直接运行<code>nload</code></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>nload
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://static.xlc520.tk/blogImage/640-16566648003664.png" alt="服务器运行数据查看工具" tabindex="0" loading="lazy"><figcaption>服务器运行数据查看工具</figcaption></figure><p>输入<code>nload</code>命令后，网络使用情况如上图所示。其中，网络使用情况分为流入网卡的数据与流出网卡的数据。流入网卡的对应下行带宽的网速，流出网卡的数据对应上行带宽的网速。如果 “当前网速” 持续接近 “最大网速” 时，代表带宽使用率已经接近100%。</p><p>指标说明：</p><ul><li>Curr：当前网速</li><li>Avg：平均网速</li><li>Min：最小网速</li><li>Max：最大网速</li><li>Ttl：总流量</li></ul><h2 id="服务器内核参数调优" tabindex="-1"><a class="header-anchor" href="#服务器内核参数调优" aria-hidden="true">#</a> <strong>服务器内核参数调优</strong></h2><p>光有强大的物理性能是不够的，还需要对内核参数进行调优，这样才能在高并发压力下充分体现服务器应有的性能。当然，并不是所有的服务器都需要做高并发性能调优，一般来说，只需要对要处理高并发请求的服务器进行内核参数调优即可，常见的包括：前端服务器，后端服务器，数据库服务器。</p><p>服务器常见的调优参数主要有两个：单个进程最大打开文件数 和 TCP相关设置。</p><h3 id="单个进程最大打开文件数" tabindex="-1"><a class="header-anchor" href="#单个进程最大打开文件数" aria-hidden="true">#</a> 单个进程最大打开文件数</h3><p>修改单个文件最大打开文件数，只需要编辑<code>/etc/security/limits.conf</code>文件，在文件末尾加上以下四句</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>* soft	nofile	<span class="token number">65535</span>
* hard	nofile	<span class="token number">65535</span>
* soft	nproc	<span class="token number">65535</span>
* hard	nproc	<span class="token number">65535</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中<code>*</code> 代表所有用户，65536代表修改的值，重启后生效。</p><h3 id="tcp相关设置" tabindex="-1"><a class="header-anchor" href="#tcp相关设置" aria-hidden="true">#</a> TCP相关设置</h3><p>修改TCP相关参数，可以优化TCP高并发通信，编辑<code>/etc/sysctl.conf</code>文件，添加以下内容</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 为防止洪水攻击，高并发系统需要将此项关闭</span>
net.ipv4.tcp_syncookies <span class="token operator">=</span> <span class="token number">0</span>

<span class="token comment"># 开启TCP连接重用，允许处理TIME-WAIT状态的连接重新用于新的TCP连接</span>
net.ipv4.tcp_tw_reuse <span class="token operator">=</span> <span class="token number">1</span>

<span class="token comment"># 开启快速回收TCP连接中处于TIME-WAIT状态的连接</span>
net.ipv4.tcp_tw_recycle <span class="token operator">=</span> <span class="token number">1</span>

＃修改超时时间（ s <span class="token punctuation">)</span>，该值表示如果连接由本端关闭，则连接处于 FIN-WAIT-2状态的时间为 
net.ipv4.tcp_fin_timeout <span class="token operator">=</span> <span class="token number">30</span>

＃当 keepalive（长连接）启用的时候，TCP发送 keepalive 消息（探测包）的时间间隔（ s <span class="token punctuation">)</span>,默认为2个小时
net.ipv4.tcp_keepalive_time <span class="token operator">=</span><span class="token number">1200</span>

＃服务器对外连接的端口范围，影响该服务器与其他服务器的连接数
net.ipv4.ip_local_port_range <span class="token operator">=</span><span class="token number">102465535</span>

<span class="token comment">#SYN队列的长度，可以容纳更多等待连接的网络连接数，默认为1024 </span>
net.ipv4.tcp_max_syn_backlog <span class="token operator">=</span> <span class="token number">65535</span>

＃保持 TIME_WAIT 状态连接的最大数量，如果超过此值，TIME_WAIT 将立刻被清除并打印警告信息，默认为180000
net.ipv4.tcp_max_tw_buckets <span class="token operator">=</span><span class="token number">5000</span>

＃每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目
net.core.netdev_max_backlog <span class="token operator">=</span><span class="token number">65535</span>

<span class="token comment"># TCP最大连接数</span>
net.core.somaxconn <span class="token operator">=</span> <span class="token number">65535</span>

＃预留用于接收缓冲的内存默认值（字节） 
net.core.rmem_default <span class="token operator">=</span> <span class="token number">8388608</span>

＃预留用于接收缓冲的内存最大值（字节） 
net.core.rmem_max <span class="token operator">=</span> <span class="token number">16777216</span>

＃预留用于发送缓冲的内存默认值（字节） 
net.core.wmem_default <span class="token operator">=</span> <span class="token number">8388608</span>

＃预留用于发送缓冲的内存最大值（字节） 
net.core.wmem_maX <span class="token operator">=</span> <span class="token number">16777216</span>

＃避免时间戳异常
net.ipv4.tcp_timestamps <span class="token operator">=</span> <span class="token number">0</span>

＃系统中最多有多少个 TCP 套接字不被关联到任何一个用户文件句柄上，如果超过这个数字，连接将即刻被复位并打印警告信息，这个限制仅仅是为了防止简单的DoS 攻击
net.ipv4.tcp_max_orphans <span class="token operator">=</span><span class="token number">3276800</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,67),l=[d];function c(t,p){return a(),e("div",null,l)}const u=n(i,[["render",c],["__file","服务器运行数据查看工具.html.vue"]]);export{u as default};
