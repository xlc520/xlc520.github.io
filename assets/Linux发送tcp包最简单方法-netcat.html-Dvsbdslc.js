import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as s,a}from"./app-DWXdHMII.js";const n={};function l(h,i){return t(),s("div",null,i[0]||(i[0]=[a('<h1 id="linux-发送-udp-tcp-包最简单方法-netcat" tabindex="-1"><a class="header-anchor" href="#linux-发送-udp-tcp-包最简单方法-netcat"><span>Linux 发送 udp/tcp 包最简单方法-netcat</span></a></h1><p>由于测试需要，需要从一台 linux 向另一台建立连接，并发送 tcp/udp 包。觉得用 python 写个 client/server 脚本有点麻烦，于是想找一个命令直接发送，一搜就搜到了 netcat</p><h2 id="网络拓扑" tabindex="-1"><a class="header-anchor" href="#网络拓扑"><span>网络拓扑</span></a></h2><figure><img src="https://bitbucket.org/xlc520/blogasset/raw/main/images3/a2ae9f6f67a64c6587f07caffddca26b.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h2 id="服务器" tabindex="-1"><a class="header-anchor" href="#服务器"><span>服务器</span></a></h2><p>先在机器 B 上进行 netcat 服务器端的配置，配置使其监听机器 B 的 6901 端口，输入以下命令</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; nc -v -n -l 192.168.0.4 6901</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这里的参数解释如下：</p><ul><li>-v 显示详细输出</li><li>-n 只使用数字的地址，不用 DNS 域名解析</li><li>-l 使用监听模式</li></ul><p>显示出第二行 Listening on... 的时候就说明监听成功啦</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Listening</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> on</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [192.168.0.4] (</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">family</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 0,</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> port</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 6901</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="客户端" tabindex="-1"><a class="header-anchor" href="#客户端"><span>客户端</span></a></h2><p>在服务器端开启成功后，我们在机器 A 上进行客户端的链接，使其链接到机器 B 的 6901 端口</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; nc -v 192.168.0.4 6901</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>按下回车后应该可以看到如下输出</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Connection</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> to</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 192.168.0.4</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 6901</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> port</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [tcp/*] succeeded!</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>同时在机器 B 的终端上会显示：</p><div class="language-typescript line-numbers-mode" data-highlighter="shiki" data-ext="typescript" data-title="typescript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">Connection</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> from</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 192.168</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0.3</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 33446</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> received</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">!</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="后记" tabindex="-1"><a class="header-anchor" href="#后记"><span>后记</span></a></h2><p>到这里 A 和 B 两台机器其实已经建立了 tcp 链接，也发过 tcp 包了。如果想要建立 udp 链接，则需要使用 -u 参数即可。建立链接之后，可以在任一机器终端输入文字并按回车，文字也会马上出现在另一台机器的终端上，比如你可以在 A 上输入：</p><div class="language-css line-numbers-mode" data-highlighter="shiki" data-ext="css" data-title="css" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">hello</span><span style="--shiki-light:#A626A4;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> I</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> am </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">A</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">. Who are you ?</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>B 的终端就会收到并展示这句话，有点互联网早期聊天的感觉。只要通过 netcat 这个小小的、简单的命令，就可以做到相互通话，操作系统提供的 socket 网络编程接口功不可没。打算有空去看看<a href="https://github.com/openbsd/src/blob/master/usr.bin/nc/netcat.c" target="_blank" rel="noopener noreferrer">netcat 的源码</a> ，从简单的命令接触 socket 编程</p>',22)]))}const c=e(n,[["render",l],["__file","Linux发送tcp包最简单方法-netcat.html.vue"]]),d=JSON.parse('{"path":"/linux/Linux%E5%8F%91%E9%80%81tcp%E5%8C%85%E6%9C%80%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95-netcat.html","title":"Linux发送udptcp包最简单方法-netcat","lang":"zh-CN","frontmatter":{"author":"xlc520","title":"Linux发送udptcp包最简单方法-netcat","excerpt":null,"description":"Linux 发送 udp/tcp 包最简单方法-netcat 由于测试需要，需要从一台 linux 向另一台建立连接，并发送 tcp/udp 包。觉得用 python 写个 client/server 脚本有点麻烦，于是想找一个命令直接发送，一搜就搜到了 netcat 网络拓扑 imgimg 服务器 先在机器 B 上进行 netcat 服务器端的配置，...","date":"2022-11-03T00:00:00.000Z","category":"Linux","tag":"Linux","article":true,"timeline":true,"icon":"linux","head":[["meta",{"property":"og:url","content":"https://blog.ciberviler.top/linux/Linux%E5%8F%91%E9%80%81tcp%E5%8C%85%E6%9C%80%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95-netcat.html"}],["meta",{"property":"og:site_name","content":"StudyNote - 丰富的知识笔记库"}],["meta",{"property":"og:title","content":"Linux发送udptcp包最简单方法-netcat"}],["meta",{"property":"og:description","content":"Linux 发送 udp/tcp 包最简单方法-netcat 由于测试需要，需要从一台 linux 向另一台建立连接，并发送 tcp/udp 包。觉得用 python 写个 client/server 脚本有点麻烦，于是想找一个命令直接发送，一搜就搜到了 netcat 网络拓扑 imgimg 服务器 先在机器 B 上进行 netcat 服务器端的配置，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://bitbucket.org/xlc520/blogasset/raw/main/images3/a2ae9f6f67a64c6587f07caffddca26b.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-27T13:32:36.000Z"}],["meta",{"property":"article:author","content":"xlc520"}],["meta",{"property":"article:tag","content":"Linux"}],["meta",{"property":"article:published_time","content":"2022-11-03T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-27T13:32:36.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Linux发送udptcp包最简单方法-netcat\\",\\"image\\":[\\"https://bitbucket.org/xlc520/blogasset/raw/main/images3/a2ae9f6f67a64c6587f07caffddca26b.png\\"],\\"datePublished\\":\\"2022-11-03T00:00:00.000Z\\",\\"dateModified\\":\\"2024-04-27T13:32:36.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xlc520\\"}]}"]]},"headers":[{"level":2,"title":"网络拓扑","slug":"网络拓扑","link":"#网络拓扑","children":[]},{"level":2,"title":"服务器","slug":"服务器","link":"#服务器","children":[]},{"level":2,"title":"客户端","slug":"客户端","link":"#客户端","children":[]},{"level":2,"title":"后记","slug":"后记","link":"#后记","children":[]}],"git":{"createdTime":1667642926000,"updatedTime":1714224756000,"contributors":[{"name":"xlc520","email":"2215400217@qq.com","commits":6},{"name":"xlc","email":"2215400217@qq.com","commits":2}]},"readingTime":{"minutes":1.67,"words":501},"filePathRelative":"linux/Linux发送tcp包最简单方法-netcat.md","localizedDate":"2022年11月3日","excerpt":"\\n<p>由于测试需要，需要从一台 linux 向另一台建立连接，并发送 tcp/udp 包。觉得用 python 写个 client/server\\n脚本有点麻烦，于是想找一个命令直接发送，一搜就搜到了 netcat</p>","autoDesc":true}');export{c as comp,d as data};
