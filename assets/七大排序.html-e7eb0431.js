const t=JSON.parse('{"key":"v-4ca9b1ff","path":"/algorithm/%E4%B8%83%E5%A4%A7%E6%8E%92%E5%BA%8F.html","title":"七大排序（代码+动图演示）","lang":"zh-CN","frontmatter":{"author":"xlc520","title":"七大排序（代码+动图演示）","description":"七大排序（代码+动图演示） 1.排序的概念及其运用 1.1排序的概念 排序：所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。 稳定性：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次 序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排 序算法是稳定的；否则称为不稳定的。 稳定性的意义：在根据多种属性进行排序时会有巨大的意义。比如我们先对学生按照学号进行了排序，再对学生进行了按照成绩进行排序，此时学号和成绩成为了两种决定因素，如果我们在按照成绩进行排序时，所使用的算法是不具有稳定性的，那么在对成绩排序后，之前根据学号进行的排序就没有意义了，此时就会出现相同成绩，但是学号靠后的在前面，反之，如果我们选择的排序具有稳定性，那么成绩相同，学号靠前的应该在前面。 内部排序：数据元素全部放在内存中的排序。 外部排序：数据元素太多不能同时放在内存中，根据排序过程的要求不能在内外存之间移动数据的排序。一般数据是存储在磁盘中的。","date":"2022-06-15T00:00:00.000Z","category":"algorithm","tag":"algorithm","article":true,"timeline":true,"icon":"article","head":[["meta",{"property":"og:url","content":"https://blog.ciberviler.top/algorithm/%E4%B8%83%E5%A4%A7%E6%8E%92%E5%BA%8F.html"}],["meta",{"property":"og:site_name","content":"StudyNote"}],["meta",{"property":"og:title","content":"七大排序（代码+动图演示）"}],["meta",{"property":"og:description","content":"七大排序（代码+动图演示） 1.排序的概念及其运用 1.1排序的概念 排序：所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。 稳定性：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次 序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排 序算法是稳定的；否则称为不稳定的。 稳定性的意义：在根据多种属性进行排序时会有巨大的意义。比如我们先对学生按照学号进行了排序，再对学生进行了按照成绩进行排序，此时学号和成绩成为了两种决定因素，如果我们在按照成绩进行排序时，所使用的算法是不具有稳定性的，那么在对成绩排序后，之前根据学号进行的排序就没有意义了，此时就会出现相同成绩，但是学号靠后的在前面，反之，如果我们选择的排序具有稳定性，那么成绩相同，学号靠前的应该在前面。 内部排序：数据元素全部放在内存中的排序。 外部排序：数据元素太多不能同时放在内存中，根据排序过程的要求不能在内外存之间移动数据的排序。一般数据是存储在磁盘中的。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-08-01T15:10:28.000Z"}],["meta",{"property":"article:author","content":"xlc520"}],["meta",{"property":"article:tag","content":"algorithm"}],["meta",{"property":"article:published_time","content":"2022-06-15T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-08-01T15:10:28.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"七大排序（代码+动图演示）\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-06-15T00:00:00.000Z\\",\\"dateModified\\":\\"2023-08-01T15:10:28.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xlc520\\"}]}"]]},"headers":[{"level":2,"title":"1.排序的概念及其运用","slug":"_1-排序的概念及其运用","link":"#_1-排序的概念及其运用","children":[{"level":3,"title":"1.1排序的概念","slug":"_1-1排序的概念","link":"#_1-1排序的概念","children":[]},{"level":3,"title":"1.2 排序的运用","slug":"_1-2-排序的运用","link":"#_1-2-排序的运用","children":[]},{"level":3,"title":"1.3 常见的排序算法","slug":"_1-3-常见的排序算法","link":"#_1-3-常见的排序算法","children":[]}]},{"level":2,"title":"2. 常见排序算法的实现","slug":"_2-常见排序算法的实现","link":"#_2-常见排序算法的实现","children":[{"level":3,"title":"2.1 插入排序","slug":"_2-1-插入排序","link":"#_2-1-插入排序","children":[]},{"level":3,"title":"2.2 选择排序","slug":"_2-2-选择排序","link":"#_2-2-选择排序","children":[]},{"level":3,"title":"2.3 交换排序","slug":"_2-3-交换排序","link":"#_2-3-交换排序","children":[]},{"level":3,"title":"2.3.2 快速排序","slug":"_2-3-2-快速排序","link":"#_2-3-2-快速排序","children":[]},{"level":3,"title":"2.4 归并排序","slug":"_2-4-归并排序","link":"#_2-4-归并排序","children":[]},{"level":3,"title":"2.5 七大排序性能测试比较","slug":"_2-5-七大排序性能测试比较","link":"#_2-5-七大排序性能测试比较","children":[]},{"level":3,"title":"2.6 非比较排序","slug":"_2-6-非比较排序","link":"#_2-6-非比较排序","children":[]}]},{"level":2,"title":"3.排序算法复杂度及稳定性分析","slug":"_3-排序算法复杂度及稳定性分析","link":"#_3-排序算法复杂度及稳定性分析","children":[]}],"git":{"createdTime":1668948234000,"updatedTime":1690902628000,"contributors":[{"name":"xlc520","email":"2215400217@qq.com","commits":4}]},"readingTime":{"minutes":32.49,"words":9746},"filePathRelative":"algorithm/七大排序.md","localizedDate":"2022年6月15日","excerpt":"<h1> 七大排序（代码+动图演示）</h1>\\n<h2> 1.排序的概念及其运用</h2>\\n<h3> 1.1排序的概念</h3>\\n<blockquote>\\n<p><strong>排序</strong>：所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。</p>\\n<p><strong>稳定性</strong>：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次 序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排 序算法是稳定的；否则称为不稳定的。</p>\\n<p><strong>稳定性的意义</strong>：在根据多种属性进行排序时会有巨大的意义。比如我们先对学生按照学号进行了排序，再对学生进行了按照成绩进行排序，此时学号和成绩成为了两种决定因素，如果我们在按照成绩进行排序时，所使用的算法是不具有稳定性的，那么在对成绩排序后，之前根据学号进行的排序就没有意义了，此时就会出现相同成绩，但是学号靠后的在前面，反之，如果我们选择的排序具有稳定性，那么成绩相同，学号靠前的应该在前面。</p>\\n<p><strong>内部排序</strong>：数据元素全部放在内存中的排序。</p>\\n<p><strong>外部排序</strong>：数据元素太多不能同时放在内存中，根据排序过程的要求不能在内外存之间移动数据的排序。<strong>一般数据是存储在磁盘中的。</strong></p>\\n</blockquote>","autoDesc":true}');export{t as data};
