import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as a,c as s,a as t}from"./app-Clq2mtAP.js";const e={},p=t(`<h1 id="快速排序" tabindex="-1"><a class="header-anchor" href="#快速排序"><span>快速排序</span></a></h1><h2 id="一、简介" tabindex="-1"><a class="header-anchor" href="#一、简介"><span>一、简介</span></a></h2><p>快速排序（Quick sort）是对冒泡排序的一种改进，是非常重要且应用比较广泛的一种高效率排序算法。</p><h2 id="二、算法思路" tabindex="-1"><a class="header-anchor" href="#二、算法思路"><span>二、算法思路</span></a></h2><p>快速排序是通过多次比较和交换来实现排序，在一趟排序中把将要排序的数据分成两个独立的部分，对这两部分进行排序使得其中一部分所有数据比另一部分都要小，然后继续递归排序这两部分，最终实现所有数据有序。</p><p>大致步骤如下：</p><h3 id="第一种" tabindex="-1"><a class="header-anchor" href="#第一种"><span>第一种</span></a></h3><ul><li><p>1.首先设置一个分界值也就是基准值又是也称为监视哨，通过该分界值将数据分割成两部分。</p></li><li><p>2.将大于或等于分界值的数据集中到右边，小于分界值的数据集中到左边。一趟排序过后，左边部分中各个数据元素都小于分界值，而右边部分中各数据元素都大于或等于分界值，且右边部分个数据元素皆大于左边所有数据元素。</p></li><li><p>3.然后，左边和右边的数据可以看成两组不同的部分，重复上述 1 和 2 步骤</p></li><li><p>当左右两部分都有序时，整个数据就完成了排序。</p></li></ul><h3 id="第二种" tabindex="-1"><a class="header-anchor" href="#第二种"><span>第二种</span></a></h3><ul><li><p>1.从序列中选择一个轴点元素 pivot 从最后一个元素向前遍历我们的策略是：每次选择第 0 位置的元素为轴点元素</p></li><li><p>2.利用 pivot 将数组分割成 2 个子数组将小于 pivot 的元素放在 pivot 的左侧将大于 pivot 的元素放在 pivot 的右侧将等于 pivot 的元素放在 pivot 的哪侧都可以，本文选择左侧</p></li><li><p>3.对子序列进行步骤 1 和步骤 2 操作直到不能再分割(子序列中只剩下一个元素)</p></li></ul><p>先介绍了下快排的执行流程，脑海中先有个大致的思路。总结一下就是先把一个大数组通过第一个元素将之分割成 2 个小的数组，并且以该轴点为界，小于它的在左边，大于它的在右边，然后递归对 2 个小数组执行步骤 1、2 操作，直到不能再分割。也许理解了一部分，别担心，接下来我会通过一个例子来带你走一遍上述的流程。</p><h2 id="三、算法步骤图解" tabindex="-1"><a class="header-anchor" href="#三、算法步骤图解"><span>三、算法步骤图解</span></a></h2><p>首先设置三个参数，first 指向区间左端，last 指向区间右端，key 为当前的分界值。</p><p>从待排序的数据元素中选取一个通常为第一个作为基准值元素（key）key=num[0]，设置双指针 first 指向区间左端，last 指向区间右端。</p><h3 id="例子演示一" tabindex="-1"><a class="header-anchor" href="#例子演示一"><span><strong>例子演示一</strong></span></a></h3><p>首先设置三个参数，first 指向区间左端，last 指向区间右端，key 为当前的分界值。</p><p>从待排序的数据元素中选取一个通常为第一个作为基准值元素（key）key=num[0]，设置双指针 first 指向区间左端，last 指向区间右端。</p><figure><img src="https://bitbucket.org/xlc520/blogasset/raw/main/images3/978b84a9b541a0db3b191993bc9fbd62.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p><strong>一、</strong></p><p>key 首先与 num[last] 进行比较，如果 num[last]&lt;key，则 num[first]=num[last]将这个比 key 小的数放到左边去，如果 num[last]&gt; =key 则- -last，再拿 num[last]与 key 进行比较，直到 num[last]&lt;key 交换元素为止。</p><figure><img src="https://bitbucket.org/xlc520/blogasset/raw/main/images3/47163d859bc7517570716e1853e67ebb.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p><strong>二、</strong> num[last]&lt;key 交换元素后，转向左边部分，用 num[first]与 key 进行比较，如果 num[first]&lt; key,则++first，然后继续进行比较，直至 num[first]&gt;key,则将 num[last]=num[first]。</p><p><img src="https://bitbucket.org/xlc520/blogasset/raw/main/images3/41a9849c2ee0619ca10dca2f0c942251.png" alt="图片" loading="lazy"><img src="https://bitbucket.org/xlc520/blogasset/raw/main/images3/c3098c79e69a9547ce8996b310ebf296.png" alt="图片" loading="lazy"></p><p><strong>三、</strong> 重复上述一二步骤</p><figure><img src="https://bitbucket.org/xlc520/blogasset/raw/main/images3/1e415f1728b314dfc9cd1c90b1dcd9af.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p><img src="https://bitbucket.org/xlc520/blogasset/raw/main/images3/ea40064bf09b7cce290866b0b47061aa.png" alt="图片" loading="lazy"><img src="https://bitbucket.org/xlc520/blogasset/raw/main/images3/50a1d73bad725027a2029378d10fbe8d.png" alt="图片" loading="lazy"><img src="https://bitbucket.org/xlc520/blogasset/raw/main/images3/a958b26d073c9bb0028b7a789934edfc.png" alt="图片" loading="lazy"><img src="https://bitbucket.org/xlc520/blogasset/raw/main/images3/9d32ef4a4b40b025e3d1c55793e6b168.png" alt="图片" loading="lazy"><img src="https://bitbucket.org/xlc520/blogasset/raw/main/images3/f9094712d3320eba982b4afe01b9eaa5.png" alt="图片" loading="lazy"><img src="https://bitbucket.org/xlc520/blogasset/raw/main/images3/4f16335e5225369f133a2c93a70efcf4.png" alt="图片" loading="lazy"><img src="https://bitbucket.org/xlc520/blogasset/raw/main/images3/a0b398c6f9c2600cc551a4e21b35ccf4.png" alt="图片" loading="lazy"><img src="https://bitbucket.org/xlc520/blogasset/raw/main/images3/4c1e553a89a57abe4ceaf726d7f52924.png" alt="图片" loading="lazy"></p><p><strong>四、</strong> 第一趟排序结束，得到[2,11,15,20,9,5] <em><strong>23</strong></em> [56,45,35] 然后对左右子数列进行同样的操作。</p><p><em><strong>2</strong></em> [11,15,20,9,5] <em><strong>23</strong></em> [35,45] <em><strong>56</strong></em></p><p><em><strong>2</strong></em> [5,9] <em><strong>11</strong></em> [20,15] <em><strong>23 35 45 56</strong></em></p><p><em><strong>2 5 9 11 15 20 23 35 45 56</strong></em></p><p>完成从小到大的排序</p><h3 id="例子演示二" tabindex="-1"><a class="header-anchor" href="#例子演示二"><span><strong>例子演示二</strong></span></a></h3><figure><img src="https://bitbucket.org/xlc520/blogasset/raw/main/images3/d53f8794a4c27d1ecff02604e5162266dfc43863.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><figure><img src="https://bitbucket.org/xlc520/blogasset/raw/main/images3/8b82b9014a90f60307aca9253bd63c13b151ed84.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><figure><img src="https://bitbucket.org/xlc520/blogasset/raw/main/images3/7aec54e736d12f2e95af5d264e065a6a8435681e.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>(注：图片中的单词 start 与 begin 同义)</strong></p><p><strong>解释下调头的事情：</strong></p><p>开始的时候是从 end 往前遍历大于 pivot 的值就 end++；小于 pivot 的值时，end 不变，并且将 end 指向的值替换 begin 指向的值，begin++从 beigin 往后遍历小于 pivot 的值就 begin++；小于 pivot 的值时，begin 不变，并且将 begin 指向的值替换 end 指向的值，end++这样交替进行</p><h3 id="动图演示" tabindex="-1"><a class="header-anchor" href="#动图演示"><span>动图演示</span></a></h3><figure><img src="https://bitbucket.org/xlc520/blogasset/raw/main/images3/quickSort.gif" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h2 id="四、算法性能分析" tabindex="-1"><a class="header-anchor" href="#四、算法性能分析"><span>四、算法性能分析</span></a></h2><p><strong>最好情况</strong> 每次数据元素都能平均的分成两个部分。得到一个完全二叉树。如果有 n 个数据元素，那么数的深度为 <img src="https://bitbucket.org/xlc520/blogasset/raw/main/images3/cc536403e247bf6f9b83d29d2ab656ae.png" alt="图片" loading="lazy"> 时间复杂度为 O(nlogn)</p><p><strong>最坏情况</strong> 在最坏的情况下，这个数仅有右子树或左子树，比较次数为 （n-1）+（n-2) + (n-3) + …… +1=n*(n-1)/2 ,因此时间复杂度为 O(n^2) ,在待排序数据元素已经有序的情况下快速排序时间复杂度最高</p><p>空间复杂度为 O(n） 快速排序是一种不稳定的排序算法，会改变数据元素的相对位置，也是内排序中平均效率最高的排序算法。</p><h2 id="五、代码实现" tabindex="-1"><a class="header-anchor" href="#五、代码实现"><span>五、代码实现</span></a></h2><h3 id="c" tabindex="-1"><a class="header-anchor" href="#c"><span><strong>C</strong></span></a></h3><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>num<span class="token punctuation">,</span><span class="token keyword">int</span> l<span class="token punctuation">,</span><span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>
 <span class="token comment">//如果小于等于1个数据元素·直接返回结束快排函数 r为数组元素总个数</span>
 <span class="token keyword">if</span><span class="token punctuation">(</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&gt;=</span>r<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 <span class="token keyword">int</span> first<span class="token operator">=</span>l<span class="token punctuation">,</span>last<span class="token operator">=</span>r<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>key<span class="token operator">=</span>num<span class="token punctuation">[</span>first<span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token keyword">while</span><span class="token punctuation">(</span>first<span class="token operator">&lt;</span>last<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>first<span class="token operator">&lt;</span>last<span class="token operator">&amp;&amp;</span>num<span class="token punctuation">[</span>last<span class="token punctuation">]</span><span class="token operator">&gt;=</span>key<span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token operator">--</span>last<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">//如果值小于 key分界值 交换 </span>
  num<span class="token punctuation">[</span>first<span class="token punctuation">]</span><span class="token operator">=</span>num<span class="token punctuation">[</span>last<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>first<span class="token operator">&lt;</span>last<span class="token operator">&amp;&amp;</span>num<span class="token punctuation">[</span>first<span class="token punctuation">]</span><span class="token operator">&lt;</span>key<span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token operator">++</span>first<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">//如果值大于key分界值 交换 </span>
  num<span class="token punctuation">[</span>last<span class="token punctuation">]</span><span class="token operator">=</span>num<span class="token punctuation">[</span>first<span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 num<span class="token punctuation">[</span>first<span class="token punctuation">]</span><span class="token operator">=</span>key<span class="token punctuation">;</span>
 <span class="token comment">//递归左右部分进行快排 </span>
 <span class="token function">quick_sort</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span>l<span class="token punctuation">,</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token function">quick_sort</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span>first<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="java" tabindex="-1"><a class="header-anchor" href="#java"><span><strong>Java</strong></span></a></h3><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> num<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token comment">//r为数组元素总个数，last下标等于r-1</span>
        <span class="token keyword">int</span> first<span class="token operator">=</span>l<span class="token punctuation">,</span>last<span class="token operator">=</span>r<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>key<span class="token operator">=</span>num<span class="token punctuation">[</span>first<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>first<span class="token operator">&lt;</span>last<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>first<span class="token operator">&lt;</span>last<span class="token operator">&amp;&amp;</span>num<span class="token punctuation">[</span>last<span class="token punctuation">]</span><span class="token operator">&gt;=</span>key<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token operator">--</span>last<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">//如果值小于 key分界值 交换</span>
            num<span class="token punctuation">[</span>first<span class="token punctuation">]</span><span class="token operator">=</span>num<span class="token punctuation">[</span>last<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>first<span class="token operator">&lt;</span>last<span class="token operator">&amp;&amp;</span>num<span class="token punctuation">[</span>first<span class="token punctuation">]</span><span class="token operator">&lt;</span>key<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token operator">++</span>first<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">//如果值大于key分界值 交换</span>
            num<span class="token punctuation">[</span>last<span class="token punctuation">]</span><span class="token operator">=</span>num<span class="token punctuation">[</span>first<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        num<span class="token punctuation">[</span>first<span class="token punctuation">]</span><span class="token operator">=</span>key<span class="token punctuation">;</span>
        <span class="token comment">//递归左右部分进行快排</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token operator">&gt;</span>l<span class="token punctuation">)</span> <span class="token punctuation">{</span>
             num<span class="token operator">=</span><span class="token function">quick_sort</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> l<span class="token punctuation">,</span> first<span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span>r<span class="token punctuation">)</span><span class="token punctuation">{</span>
            num<span class="token operator">=</span><span class="token function">quick_sort</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span>first<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> num<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="六、视频" tabindex="-1"><a class="header-anchor" href="#六、视频"><span>六、视频</span></a></h2><video id="video" controls="" preload="none" width="720px"><source id="mp4" src="https://static.linch.eu.org/blogVideo/quickSort.mp4" type="video/mp4"></video>`,51),i=[p];function o(c,l){return a(),s("div",null,i)}const d=n(e,[["render",o],["__file","快速排序.html.vue"]]),k=JSON.parse('{"path":"/algorithm/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html","title":"快速排序","lang":"zh-CN","frontmatter":{"author":"xlc520","title":"快速排序","excerpt":"快速排序（Quick sort）是对冒泡排序的一种改进，是非常重要且应用比较广泛的一种高效率排序算法","description":"快速排序（Quick sort）是对冒泡排序的一种改进，是非常重要且应用比较广泛的一种高效率排序算法","date":"2022-05-30T00:00:00.000Z","category":"algorithm","tag":["algorithm","排序"],"article":true,"timeline":true,"icon":"article","head":[["meta",{"property":"og:url","content":"https://blog.ciberviler.top/algorithm/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html"}],["meta",{"property":"og:site_name","content":"StudyNote - 丰富的知识笔记库"}],["meta",{"property":"og:title","content":"快速排序"}],["meta",{"property":"og:description","content":"快速排序（Quick sort）是对冒泡排序的一种改进，是非常重要且应用比较广泛的一种高效率排序算法"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://bitbucket.org/xlc520/blogasset/raw/main/images3/978b84a9b541a0db3b191993bc9fbd62.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-27T13:32:36.000Z"}],["meta",{"property":"article:author","content":"xlc520"}],["meta",{"property":"article:tag","content":"algorithm"}],["meta",{"property":"article:tag","content":"排序"}],["meta",{"property":"article:published_time","content":"2022-05-30T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-27T13:32:36.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"快速排序\\",\\"image\\":[\\"https://bitbucket.org/xlc520/blogasset/raw/main/images3/978b84a9b541a0db3b191993bc9fbd62.png\\",\\"https://bitbucket.org/xlc520/blogasset/raw/main/images3/47163d859bc7517570716e1853e67ebb.png\\",\\"https://bitbucket.org/xlc520/blogasset/raw/main/images3/41a9849c2ee0619ca10dca2f0c942251.png\\",\\"https://bitbucket.org/xlc520/blogasset/raw/main/images3/c3098c79e69a9547ce8996b310ebf296.png\\",\\"https://bitbucket.org/xlc520/blogasset/raw/main/images3/1e415f1728b314dfc9cd1c90b1dcd9af.png\\",\\"https://bitbucket.org/xlc520/blogasset/raw/main/images3/ea40064bf09b7cce290866b0b47061aa.png\\",\\"https://bitbucket.org/xlc520/blogasset/raw/main/images3/50a1d73bad725027a2029378d10fbe8d.png\\",\\"https://bitbucket.org/xlc520/blogasset/raw/main/images3/a958b26d073c9bb0028b7a789934edfc.png\\",\\"https://bitbucket.org/xlc520/blogasset/raw/main/images3/9d32ef4a4b40b025e3d1c55793e6b168.png\\",\\"https://bitbucket.org/xlc520/blogasset/raw/main/images3/f9094712d3320eba982b4afe01b9eaa5.png\\",\\"https://bitbucket.org/xlc520/blogasset/raw/main/images3/4f16335e5225369f133a2c93a70efcf4.png\\",\\"https://bitbucket.org/xlc520/blogasset/raw/main/images3/a0b398c6f9c2600cc551a4e21b35ccf4.png\\",\\"https://bitbucket.org/xlc520/blogasset/raw/main/images3/4c1e553a89a57abe4ceaf726d7f52924.png\\",\\"https://bitbucket.org/xlc520/blogasset/raw/main/images3/d53f8794a4c27d1ecff02604e5162266dfc43863.png\\",\\"https://bitbucket.org/xlc520/blogasset/raw/main/images3/8b82b9014a90f60307aca9253bd63c13b151ed84.png\\",\\"https://bitbucket.org/xlc520/blogasset/raw/main/images3/7aec54e736d12f2e95af5d264e065a6a8435681e.png\\",\\"https://bitbucket.org/xlc520/blogasset/raw/main/images3/quickSort.gif\\",\\"https://bitbucket.org/xlc520/blogasset/raw/main/images3/cc536403e247bf6f9b83d29d2ab656ae.png\\"],\\"datePublished\\":\\"2022-05-30T00:00:00.000Z\\",\\"dateModified\\":\\"2024-04-27T13:32:36.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xlc520\\"}]}"]]},"headers":[{"level":2,"title":"一、简介","slug":"一、简介","link":"#一、简介","children":[]},{"level":2,"title":"二、算法思路","slug":"二、算法思路","link":"#二、算法思路","children":[{"level":3,"title":"第一种","slug":"第一种","link":"#第一种","children":[]},{"level":3,"title":"第二种","slug":"第二种","link":"#第二种","children":[]}]},{"level":2,"title":"三、算法步骤图解","slug":"三、算法步骤图解","link":"#三、算法步骤图解","children":[{"level":3,"title":"例子演示一","slug":"例子演示一","link":"#例子演示一","children":[]},{"level":3,"title":"例子演示二","slug":"例子演示二","link":"#例子演示二","children":[]},{"level":3,"title":"动图演示","slug":"动图演示","link":"#动图演示","children":[]}]},{"level":2,"title":"四、算法性能分析","slug":"四、算法性能分析","link":"#四、算法性能分析","children":[]},{"level":2,"title":"五、代码实现","slug":"五、代码实现","link":"#五、代码实现","children":[{"level":3,"title":"C","slug":"c","link":"#c","children":[]},{"level":3,"title":"Java","slug":"java","link":"#java","children":[]}]},{"level":2,"title":"六、视频","slug":"六、视频","link":"#六、视频","children":[]}],"git":{"createdTime":1653795126000,"updatedTime":1714224756000,"contributors":[{"name":"xlc520","email":"2215400217@qq.com","commits":5},{"name":"xlc","email":"2215400217@qq.com","commits":2}]},"readingTime":{"minutes":5.79,"words":1736},"filePathRelative":"algorithm/快速排序.md","localizedDate":"2022年5月30日"}');export{d as comp,k as data};
