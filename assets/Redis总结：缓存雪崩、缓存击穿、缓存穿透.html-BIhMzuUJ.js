import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as a,c as t,a as i}from"./app-CHLzVell.js";const l={},n=i('<h1 id="redis-总结-缓存雪崩、缓存击穿、缓存穿透与缓存预热、缓存降级" tabindex="-1"><a class="header-anchor" href="#redis-总结-缓存雪崩、缓存击穿、缓存穿透与缓存预热、缓存降级"><span>Redis 总结：缓存雪崩、缓存击穿、缓存穿透与缓存预热、缓存降级</span></a></h1><h2 id="_01-缓存雪崩" tabindex="-1"><a class="header-anchor" href="#_01-缓存雪崩"><span>01 缓存雪崩</span></a></h2><h3 id="_1-1-什么是缓存雪崩" tabindex="-1"><a class="header-anchor" href="#_1-1-什么是缓存雪崩"><span>1.1 什么是缓存雪崩？</span></a></h3><p>如果缓在某一个时刻出现大规模的 key 失效，那么就会导致大量的请求打在了数据库上面，导致数据库压力巨大，如果在高并发的情况下，可能瞬间就会导致数据库宕机。这时候如果运维马上又重启数据库，马上又会有新的流量把数据库打死。这就是缓存雪崩。</p><h3 id="_1-2-缓存雪崩问题分析" tabindex="-1"><a class="header-anchor" href="#_1-2-缓存雪崩问题分析"><span>1.2 缓存雪崩问题分析</span></a></h3><p>造成缓存雪崩的关键在于同一时间的大规模的 key 失效，为什么会出现这个问题，主要有两种可能：第一种是 Redis 宕机，第二种可能就是采用了相同的过期时间。搞清楚原因之后，那么有什么解决方案呢？</p><h3 id="_1-3-缓存雪崩解决方案" tabindex="-1"><a class="header-anchor" href="#_1-3-缓存雪崩解决方案"><span>1.3 缓存雪崩解决方案</span></a></h3><p><strong>（1）事前</strong></p><p>① 均匀过期：设置不同的过期时间，让缓存失效的时间尽量均匀，避免相同的过期时间导致缓存雪崩，造成大量数据库的访问。</p><p>② 分级缓存：第一级缓存失效的基础上，访问二级缓存，每一级缓存的失效时间都不同。</p><p>③ 热点数据缓存永远不过期。</p><blockquote><p>永不过期实际包含两层意思：</p><p>物理不过期，针对热点 key 不设置过期时间</p><p>逻辑过期，把过期时间存在 key 对应的 value 里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建</p></blockquote><p>④ 保证 Redis 缓存的高可用，防止 Redis 宕机导致缓存雪崩的问题。可以使用 主从+ 哨兵，Redis 集群来避免 Redis 全盘崩溃的情况。</p><p><strong>（2）事中</strong></p><p>① 互斥锁：在缓存失效后，通过互斥锁或者队列来控制读数据写缓存的线程数量，比如某个 key 只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他的线程，此时系统的吞吐量会下降</p><p>② 使用熔断机制，限流降级。当流量达到一定的阈值，直接返回“系统拥挤”之类的提示，防止过多的请求打在数据库上将数据库击垮，至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果。</p><p><strong>（3）事后</strong></p><p>① 开启 Redis 持久化机制，尽快恢复缓存数据，一旦重启，就能从磁盘上自动加载数据恢复内存中的数据。</p><h2 id="_02-缓存击穿" tabindex="-1"><a class="header-anchor" href="#_02-缓存击穿"><span>02 缓存击穿</span></a></h2><h3 id="_2-1-什么是缓存击穿" tabindex="-1"><a class="header-anchor" href="#_2-1-什么是缓存击穿"><span>2.1 什么是缓存击穿？</span></a></h3><p>缓存击穿跟缓存雪崩有点类似，缓存雪崩是大规模的 key 失效，而缓存击穿是某个热点的 key 失效，大并发集中对其进行请求，就会造成大量请求读缓存没读到数据，从而导致高并发访问数据库，引起数据库压力剧增。这种现象就叫做缓存击穿。</p><h3 id="_2-2-缓存击穿问题分析" tabindex="-1"><a class="header-anchor" href="#_2-2-缓存击穿问题分析"><span>2.2 缓存击穿问题分析</span></a></h3><p>关键在于某个热点的 key 失效了，导致大并发集中打在数据库上。所以要从两个方面解决，第一是否可以考虑热点 key 不设置过期时间，第二是否可以考虑降低打在数据库上的请求数量。</p><h3 id="_2-3-缓存击穿解决方案" tabindex="-1"><a class="header-anchor" href="#_2-3-缓存击穿解决方案"><span>2.3 缓存击穿解决方案</span></a></h3><p>（1）在缓存失效后，通过互斥锁或者队列来控制读数据写缓存的线程数量，比如某个 key 只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他的线程，此时系统的吞吐量会下降</p><p>（2）热点数据缓存永远不过期。</p><p>永不过期实际包含两层意思：</p><ul><li>物理不过期，针对热点 key 不设置过期时间</li><li>逻辑过期，把过期时间存在 key 对应的 value 里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建</li></ul><h2 id="_03-缓存穿透" tabindex="-1"><a class="header-anchor" href="#_03-缓存穿透"><span>03 缓存穿透</span></a></h2><h3 id="_3-1-什么是缓存穿透" tabindex="-1"><a class="header-anchor" href="#_3-1-什么是缓存穿透"><span>3.1 什么是缓存穿透？</span></a></h3><p>缓存穿透是指用户请求的数据在缓存中不存在即没有命中，同时在数据库中也不存在，导致用户每次请求该数据都要去数据库中查询一遍。如果有恶意攻击者不断请求系统中不存在的数据，会导致短时间大量请求落在数据库上，造成数据库压力过大，甚至导致数据库承受不住而宕机崩溃。</p><h3 id="_3-2-问题分析" tabindex="-1"><a class="header-anchor" href="#_3-2-问题分析"><span>3.2 问题分析</span></a></h3><p>缓存穿透的关键在于在 Redis 中查不到 key 值，它和缓存击穿的根本区别在于传进来的 key 在 Redis 中是不存在的。假如有黑客传进大量的不存在的 key，那么大量的请求打在数据库上是很致命的问题，所以在日常开发中要对参数做好校验，一些非法的参数，不可能存在的 key 就直接返回错误提示。</p><figure><img src="https://bitbucket.org/xlc520/blogasset/raw/main/images3/640-1674184514758-0.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h3 id="_3-3-解决方法" tabindex="-1"><a class="header-anchor" href="#_3-3-解决方法"><span>3.3 解决方法</span></a></h3><p><strong>（1）将无效的 key 存放进 Redis 中：</strong></p><p>当出现 Redis 查不到数据，数据库也查不到数据的情况，我们就把这个 key 保存到 Redis 中，设置 value=&quot;null&quot; ，并设置其过期时间极短，后面再出现查询这个 key 的请求的时候，直接返回 null，就不需要再查询数据库了。但这种处理方式是有问题的，假如传进来的这个不存在的 Key 值每次都是随机的，那存进 Redis 也没有意义。</p><p><strong>（2）使用布隆过滤器：</strong></p><p>如果布隆过滤器判定某个 key 不存在布隆过滤器中，那么就一定不存在，如果判定某个 key 存在，那么很大可能是存在( 存在一定的误判率)。于是我们可以在缓存之前再加一个布隆过滤器，将数据库中的所有 key 都存储在布隆过滤器中，在查询 Redis 前先去布隆过滤器查询 key 是否存在，如果不存在就直接返回，不让其访问数据库，从而避免了对底层存储系统的查询压力。</p><figure><img src="https://bitbucket.org/xlc520/blogasset/raw/main/images3/640-1674184544998-3.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>如何选择：针对一些恶意攻击，攻击带过来的大量 key 是随机，那么我们采用第一种方案就会缓存大量不存在 key 的数据。那么这种方案就不合适了，我们可以先对使用布隆过滤器方案进行过滤掉这些 key。所以，针对这种 key 异常多、请求重复率比较低的数据，优先使用第二种方案直接过滤掉。而对于空数据的 key 有限的，重复率比较高的，则可优先采用第一种方式进行缓存。</p><h2 id="_04-缓存预热" tabindex="-1"><a class="header-anchor" href="#_04-缓存预热"><span>04 缓存预热</span></a></h2><h3 id="_4-1-什么是缓存预热" tabindex="-1"><a class="header-anchor" href="#_4-1-什么是缓存预热"><span>4.1 什么是缓存预热？</span></a></h3><p>缓存预热是指系统上线后，提前将相关的缓存数据加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题，用户直接查询事先被预热的缓存数据。</p><p>如果不进行预热，那么 Redis 初始状态数据为空，系统上线初期，对于高并发的流量，都会访问到数据库中， 对数据库造成流量的压力。</p><h3 id="_4-2-缓存预热解决方案" tabindex="-1"><a class="header-anchor" href="#_4-2-缓存预热解决方案"><span>4.2 缓存预热解决方案</span></a></h3><p>（1）数据量不大的时候，工程启动的时候进行加载缓存动作；</p><p>（2）数据量大的时候，设置一个定时任务脚本，进行缓存的刷新；</p><p>（3）数据量太大的时候，优先保证热点数据进行提前加载到缓存。</p><h2 id="_05-缓存降级" tabindex="-1"><a class="header-anchor" href="#_05-缓存降级"><span>05 缓存降级</span></a></h2><p>缓存降级是指缓存失效或缓存服务器挂掉的情况下，不去访问数据库，直接返回默认数据或访问服务的内存数据。降级一般是有损的操作，所以尽量减少降级对于业务的影响程度。</p><p>在项目实战中通常会将部分热点数据缓存到服务的内存中，这样一旦缓存出现异常，可以直接使用服务的内存数据，从而避免数据库遭受巨大压力。</p>',52),s=[n];function p(r,d){return a(),t("div",null,s)}const o=e(l,[["render",p],["__file","Redis总结：缓存雪崩、缓存击穿、缓存穿透.html.vue"]]),_=JSON.parse('{"path":"/dev/Redis%E6%80%BB%E7%BB%93%EF%BC%9A%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F.html","title":"Redis总结：缓存雪崩、缓存击穿、缓存穿透与缓存预热、缓存降级","lang":"zh-CN","frontmatter":{"author":"xlc520","title":"Redis总结：缓存雪崩、缓存击穿、缓存穿透与缓存预热、缓存降级","excerpt":null,"description":"Redis总结：缓存雪崩、缓存击穿、缓存穿透与缓存预热、缓存降级","date":"2022-04-25T00:00:00.000Z","category":"Java","tag":"Java","article":true,"timeline":true,"icon":"java","head":[["meta",{"property":"og:url","content":"https://blog.ciberviler.top/dev/Redis%E6%80%BB%E7%BB%93%EF%BC%9A%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F.html"}],["meta",{"property":"og:site_name","content":"StudyNote - 丰富的知识笔记库"}],["meta",{"property":"og:title","content":"Redis总结：缓存雪崩、缓存击穿、缓存穿透与缓存预热、缓存降级"}],["meta",{"property":"og:description","content":"Redis总结：缓存雪崩、缓存击穿、缓存穿透与缓存预热、缓存降级"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://bitbucket.org/xlc520/blogasset/raw/main/images3/640-1674184514758-0.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-27T13:32:36.000Z"}],["meta",{"property":"article:author","content":"xlc520"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:published_time","content":"2022-04-25T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-27T13:32:36.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis总结：缓存雪崩、缓存击穿、缓存穿透与缓存预热、缓存降级\\",\\"image\\":[\\"https://bitbucket.org/xlc520/blogasset/raw/main/images3/640-1674184514758-0.png\\",\\"https://bitbucket.org/xlc520/blogasset/raw/main/images3/640-1674184544998-3.png\\"],\\"datePublished\\":\\"2022-04-25T00:00:00.000Z\\",\\"dateModified\\":\\"2024-04-27T13:32:36.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xlc520\\"}]}"]]},"headers":[{"level":2,"title":"01 缓存雪崩","slug":"_01-缓存雪崩","link":"#_01-缓存雪崩","children":[{"level":3,"title":"1.1 什么是缓存雪崩？","slug":"_1-1-什么是缓存雪崩","link":"#_1-1-什么是缓存雪崩","children":[]},{"level":3,"title":"1.2 缓存雪崩问题分析","slug":"_1-2-缓存雪崩问题分析","link":"#_1-2-缓存雪崩问题分析","children":[]},{"level":3,"title":"1.3 缓存雪崩解决方案","slug":"_1-3-缓存雪崩解决方案","link":"#_1-3-缓存雪崩解决方案","children":[]}]},{"level":2,"title":"02 缓存击穿","slug":"_02-缓存击穿","link":"#_02-缓存击穿","children":[{"level":3,"title":"2.1 什么是缓存击穿？","slug":"_2-1-什么是缓存击穿","link":"#_2-1-什么是缓存击穿","children":[]},{"level":3,"title":"2.2 缓存击穿问题分析","slug":"_2-2-缓存击穿问题分析","link":"#_2-2-缓存击穿问题分析","children":[]},{"level":3,"title":"2.3 缓存击穿解决方案","slug":"_2-3-缓存击穿解决方案","link":"#_2-3-缓存击穿解决方案","children":[]}]},{"level":2,"title":"03 缓存穿透","slug":"_03-缓存穿透","link":"#_03-缓存穿透","children":[{"level":3,"title":"3.1 什么是缓存穿透？","slug":"_3-1-什么是缓存穿透","link":"#_3-1-什么是缓存穿透","children":[]},{"level":3,"title":"3.2 问题分析","slug":"_3-2-问题分析","link":"#_3-2-问题分析","children":[]},{"level":3,"title":"3.3 解决方法","slug":"_3-3-解决方法","link":"#_3-3-解决方法","children":[]}]},{"level":2,"title":"04 缓存预热","slug":"_04-缓存预热","link":"#_04-缓存预热","children":[{"level":3,"title":"4.1 什么是缓存预热？","slug":"_4-1-什么是缓存预热","link":"#_4-1-什么是缓存预热","children":[]},{"level":3,"title":"4.2 缓存预热解决方案","slug":"_4-2-缓存预热解决方案","link":"#_4-2-缓存预热解决方案","children":[]}]},{"level":2,"title":"05 缓存降级","slug":"_05-缓存降级","link":"#_05-缓存降级","children":[]}],"git":{"createdTime":1651023828000,"updatedTime":1714224756000,"contributors":[{"name":"xlc520","email":"2215400217@qq.com","commits":5},{"name":"xlc","email":"2215400217@qq.com","commits":2}]},"readingTime":{"minutes":7.24,"words":2172},"filePathRelative":"dev/Redis总结：缓存雪崩、缓存击穿、缓存穿透.md","localizedDate":"2022年4月25日"}');export{o as comp,_ as data};
