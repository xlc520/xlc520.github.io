const e=JSON.parse('{"key":"v-306f125d","path":"/study/vue3_quick_study/chapter4/02_Composition%20API_%E5%85%B6%E5%AE%83%E9%83%A8%E5%88%86.html","title":"Composition API","lang":"zh-CN","frontmatter":{"author":"xlc520","title":"Composition API","description":"2. Composition API(其它部分) 1) shallowReactive 与 shallowRef shallowReactive : 只处理了对象内最外层属性的响应式(也就是浅响应式) shallowRef: 只处理了value的响应式, 不进行对象的reactive处理 什么时候用浅响应式呢? 一般情况下使用ref和reactive即...","date":"2022-07-31T00:00:00.000Z","category":"Vue","tag":"Vue","article":true,"dateline":true,"icon":"vue","head":[["meta",{"property":"og:url","content":"https://blog.ciberviler.top/study/vue3_quick_study/chapter4/02_Composition%20API_%E5%85%B6%E5%AE%83%E9%83%A8%E5%88%86.html"}],["meta",{"property":"og:site_name","content":"StudyNote"}],["meta",{"property":"og:title","content":"Composition API"}],["meta",{"property":"og:description","content":"2. Composition API(其它部分) 1) shallowReactive 与 shallowRef shallowReactive : 只处理了对象内最外层属性的响应式(也就是浅响应式) shallowRef: 只处理了value的响应式, 不进行对象的reactive处理 什么时候用浅响应式呢? 一般情况下使用ref和reactive即..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-03-15T09:41:05.000Z"}],["meta",{"property":"article:author","content":"xlc520"}],["meta",{"property":"article:tag","content":"Vue"}],["meta",{"property":"article:published_time","content":"2022-07-31T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-03-15T09:41:05.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Composition API\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-07-31T00:00:00.000Z\\",\\"dateModified\\":\\"2023-03-15T09:41:05.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xlc520\\"}]}"]]},"headers":[{"level":2,"title":"1) shallowReactive 与 shallowRef","slug":"_1-shallowreactive-与-shallowref","link":"#_1-shallowreactive-与-shallowref","children":[]},{"level":2,"title":"2) readonly 与 shallowReadonly","slug":"_2-readonly-与-shallowreadonly","link":"#_2-readonly-与-shallowreadonly","children":[]},{"level":2,"title":"3) toRaw 与 markRaw","slug":"_3-toraw-与-markraw","link":"#_3-toraw-与-markraw","children":[]},{"level":2,"title":"4) toRef","slug":"_4-toref","link":"#_4-toref","children":[]},{"level":2,"title":"5) customRef","slug":"_5-customref","link":"#_5-customref","children":[]},{"level":2,"title":"6) provide 与 inject","slug":"_6-provide-与-inject","link":"#_6-provide-与-inject","children":[]},{"level":2,"title":"7) 响应式数据的判断","slug":"_7-响应式数据的判断","link":"#_7-响应式数据的判断","children":[]}],"git":{"createdTime":1668948234000,"updatedTime":1678873265000,"contributors":[{"name":"xlc520","email":"2215400217@qq.com","commits":2}]},"readingTime":{"minutes":5.92,"words":1776},"filePathRelative":"study/vue3_quick_study/chapter4/02_Composition API_其它部分.md","localizedDate":"2022年7月31日","excerpt":"\\n<h2>1) shallowReactive 与 shallowRef</h2>\\n<ul>\\n<li>\\n<p>shallowReactive : 只处理了对象内最外层属性的响应式(也就是浅响应式)</p>\\n</li>\\n<li>\\n<p>shallowRef: 只处理了value的响应式, 不进行对象的reactive处理</p>\\n</li>\\n<li>\\n<p>什么时候用浅响应式呢?</p>\\n<ul>\\n<li>一般情况下使用ref和reactive即可</li>\\n<li>如果有一个对象数据, 结构比较深, 但变化时只是外层属性变化 ===&gt; shallowReactive</li>\\n<li>如果有一个对象数据, 后面会产生新的对象来替换 ===&gt; shallowRef</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{e as data};
