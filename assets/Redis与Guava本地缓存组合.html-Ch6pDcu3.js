import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as p,o as c,c as i,d as n,e as s,b as l,a}from"./app-BRQZ0-Iq.js";const o={},u=a(`<h1 id="redis-与-guava-本地缓存组合" tabindex="-1"><a class="header-anchor" href="#redis-与-guava-本地缓存组合"><span>Redis 与 Guava 本地缓存组合</span></a></h1><figure><img src="https://bitbucket.org/xlc520/blogasset/raw/main/images3/98d8c80f6ae24256832ae271c74d81f2tplv-k3u1fbpfcp-zoom-crop-mark3024302430241702.webp" alt="Redis与本地缓存组合" tabindex="0" loading="lazy"><figcaption>Redis与本地缓存组合</figcaption></figure><h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2><p>我们开发中经常用到 Redis 作为缓存，将高频数据放在 Redis 中能够提高业务性能，降低 MySQL 等关系型数据库压力，甚至一些系统使用 Redis 进行数据持久化，Redis 松散的文档结构非常适合业务系统开发，在精确查询，数据统计业务有着很大的优势。但是高频数据流处理系统中，Redis 的压力也会很大，同时 I/0 开销才是耗时的主要原因，这时候为了降低 Redis 读写压力我们可以用到本地缓存，Guava 为我们提供了优秀的本地缓存 API，包含了过期策略等等，编码难度低，个人非常推荐。</p><h2 id="设计示例" tabindex="-1"><a class="header-anchor" href="#设计示例"><span>设计示例</span></a></h2><h2 id="redis-懒加载缓存" tabindex="-1"><a class="header-anchor" href="#redis-懒加载缓存"><span>Redis 懒加载缓存</span></a></h2><blockquote><p>数据在新增到 MySQL 不进行缓存，在精确查找进行缓存，做到查询即缓存，不查询不缓存</p></blockquote><h3 id="流程图" tabindex="-1"><a class="header-anchor" href="#流程图"><span>流程图</span></a></h3><figure><img src="https://bitbucket.org/xlc520/blogasset/raw/main/images3/98a4b375d0444e589b217a94065219aatplv-k3u1fbpfcp-zoom-in-crop-mark4536000.png" alt="Redis懒加载缓存.png" tabindex="0" loading="lazy"><figcaption>Redis懒加载缓存.png</figcaption></figure><h3 id="代码示例" tabindex="-1"><a class="header-anchor" href="#代码示例"><span>代码示例</span></a></h3><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 伪代码示例 Xx代表你的的业务对象 如User Goods等等</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">XxLazyCache</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Xx</span><span class="token punctuation">&gt;</span></span> redisTemplate<span class="token punctuation">;</span>
    
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">XxService</span> xxService<span class="token punctuation">;</span><span class="token comment">// 你的业务service</span>
    
    <span class="token doc-comment comment">/**
     * 查询 通过查询缓存是否存在驱动缓存加载 建议在前置业务保证id对应数据是绝对存在于数据库中的
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">Xx</span> <span class="token function">getXx</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 1.查询缓存里面有没有数据</span>
        <span class="token class-name">Xx</span> xxCache <span class="token operator">=</span> <span class="token function">getXxFromCache</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>xxCache <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> xxCache<span class="token punctuation">;</span><span class="token comment">// 卫语句使代码更有利于阅读</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 2.查询数据库获取数据 我们假定到业务这一步，传过来的id都在数据库中有对应数据</span>
        <span class="token class-name">Xx</span> xx <span class="token operator">=</span> xxService<span class="token punctuation">.</span><span class="token function">getXxById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 3.设置缓存、这一步相当于Redis缓存懒加载，下次再查询此id，则会走缓存</span>
        <span class="token function">setXxFromCache</span><span class="token punctuation">(</span>xx<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> xx<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    
    <span class="token doc-comment comment">/**
     * 对xx数据进行修改或者删除操作 操作数据库成功后 删除缓存
     * 删除请求 - 删除数据库数据 删除缓存
     * 修改请求 - 更新数据库数据 删除缓存 下次在查询时候就会从数据库拉取新的数据到缓存中
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">deleteXxFromCache</span><span class="token punctuation">(</span><span class="token keyword">long</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> key <span class="token operator">=</span> <span class="token string">&quot;Xx:&quot;</span> <span class="token operator">+</span> xx<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        redisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setXxFromCache</span><span class="token punctuation">(</span><span class="token class-name">Xx</span> xx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> key <span class="token operator">=</span> <span class="token string">&quot;Xx:&quot;</span> <span class="token operator">+</span> xx<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> xx<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">private</span> <span class="token class-name">Xx</span> <span class="token function">getXxFromCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 通过缓存前缀拼装唯一主键作为缓存Key 如Xxx信息 就是Xxx:id</span>
        <span class="token class-name">String</span> key <span class="token operator">=</span> <span class="token string">&quot;Xx:&quot;</span> <span class="token operator">+</span> id<span class="token punctuation">;</span>
        <span class="token keyword">return</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
<span class="token punctuation">}</span>
<span class="token comment">// 业务类</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">XxServie</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">XxLazyCache</span> xxLazyCache<span class="token punctuation">;</span>
    <span class="token comment">// 查询数据库</span>
    <span class="token keyword">public</span> <span class="token class-name">Xx</span> <span class="token function">getXxById</span><span class="token punctuation">(</span><span class="token keyword">long</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 省略实现</span>
        <span class="token keyword">return</span> xx<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">updateXx</span><span class="token punctuation">(</span><span class="token class-name">Xx</span> xx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 更新MySQL数据 省略</span>
        <span class="token comment">// 删除缓存</span>
        xxLazyCache<span class="token punctuation">.</span><span class="token function">deleteXxFromCache</span><span class="token punctuation">(</span>xx<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">deleteXx</span><span class="token punctuation">(</span><span class="token keyword">long</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 删除MySQL数据 省略</span>
        <span class="token comment">// 删除缓存</span>
        xxLazyCache<span class="token punctuation">.</span><span class="token function">deleteXxFromCache</span><span class="token punctuation">(</span>xx<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 实体类</span>
<span class="token annotation punctuation">@Data</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Xx</span> <span class="token punctuation">{</span>
    <span class="token comment">// 业务主键</span>
    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>
    <span class="token comment">// ...省略</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="优点" tabindex="-1"><a class="header-anchor" href="#优点"><span>优点</span></a></h3><ul><li>保证最小的缓存量满足精确查询业务，避免冷数据占用宝贵的内存空间</li><li>对增删改查业务入侵小、删除即同步</li><li>可插拔，对于老系统升级，历史数据无需在启动时初始化缓存</li></ul><h3 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点"><span>缺点</span></a></h3><ul><li>数据量需可控，在无限增长业务场景不适用</li><li>在微服务场景不利于全局缓存应用</li></ul><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><ul><li>空间最小化</li><li>满足精确查询场景</li><li>总数据量可控推荐使用</li><li>微服务场景不适用</li></ul><h2 id="redis-结合本地缓存" tabindex="-1"><a class="header-anchor" href="#redis-结合本地缓存"><span>Redis 结合本地缓存</span></a></h2><blockquote><p>微服务场景下，多个微服务使用一个大缓存，流数据业务下，高频读取缓存对 Redis 压力很大，我们使用本地缓存结合 Redis 缓存使用，降低 Redis 压力，同时本地缓存没有连接开销，性能更优</p></blockquote><h3 id="流程图-1" tabindex="-1"><a class="header-anchor" href="#流程图-1"><span>流程图</span></a></h3><figure><img src="https://bitbucket.org/xlc520/blogasset/raw/main/images3/1028922154004ccc9c2811c75325efdctplv-k3u1fbpfcp-zoom-in-crop-mark4536000.png" alt="本地缓存.png" tabindex="0" loading="lazy"><figcaption>本地缓存.png</figcaption></figure><h3 id="业务场景" tabindex="-1"><a class="header-anchor" href="#业务场景"><span>业务场景</span></a></h3>`,22),d={href:"https://juejin.cn/post/6995746569580445709",target:"_blank",rel:"noopener noreferrer"},r=a(`<h3 id="代码示例-1" tabindex="-1"><a class="header-anchor" href="#代码示例-1"><span>代码示例</span></a></h3><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 此缓存演示如何结合redis自增数 hash 本地缓存使用进行设备自增数的生成、缓存、本地缓存
 * 本地缓存使用Guava Cache
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DeviceIncCache</span> <span class="token punctuation">{</span>

    <span class="token doc-comment comment">/**
     * 本地缓存
     */</span>
    <span class="token keyword">private</span> <span class="token class-name">Cache</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> localCache <span class="token operator">=</span> <span class="token class-name">CacheBuilder</span><span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">concurrencyLevel</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span> <span class="token comment">// 并发级别</span>
        <span class="token punctuation">.</span><span class="token function">initialCapacity</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token comment">// 初始容量</span>
        <span class="token punctuation">.</span><span class="token function">maximumSize</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span> <span class="token comment">// 缓存最大长度</span>
        <span class="token punctuation">.</span><span class="token function">expireAfterAccess</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">HOURS</span><span class="token punctuation">)</span> <span class="token comment">// 缓存1小时没被使用就过期</span>
        <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> redisTemplate<span class="token punctuation">;</span>
    
    <span class="token doc-comment comment">/**
     * redis自增数缓存的key
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">DEVICE_INC_COUNT</span> <span class="token operator">=</span> <span class="token string">&quot;device_inc_count&quot;</span><span class="token punctuation">;</span>
    
    <span class="token doc-comment comment">/**
     * redis设备编码对应自增数的hash缓存key
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">DEVICE_INC_VALUE</span> <span class="token operator">=</span> <span class="token string">&quot;device_inc_value&quot;</span><span class="token punctuation">;</span>
    
    <span class="token doc-comment comment">/**
     * 获取设备自增数
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getInc</span><span class="token punctuation">(</span><span class="token class-name">String</span> deviceCode<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// 1.从本地缓存获取</span>
        <span class="token class-name">Integer</span> inc <span class="token operator">=</span> localCache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>deviceCode<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>inc <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> inc<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 2.本地缓存未命中，从redis的hash缓存获取</span>
        inc <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">)</span>redisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token constant">DEVICE_INC_VALUE</span><span class="token punctuation">,</span> deviceCode<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 3. redis的hash缓存中没有，说明是新设备，先为设备生成一个自增号</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>inc <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            inc <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token constant">DEVICE_INC_COUNT</span><span class="token punctuation">)</span><span class="token punctuation">.</span>intValue<span class="token punctuation">;</span>
            <span class="token comment">// 添加到redis hash缓存</span>
            redisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token constant">DEVICE_INC_VALUE</span><span class="token punctuation">,</span> deviceCode<span class="token punctuation">,</span> inc<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 4.添加到本地缓存</span>
        localCache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>deviceCode<span class="token punctuation">,</span> inc<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 4.返回自增数</span>
        <span class="token keyword">return</span> inc<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="优点-1" tabindex="-1"><a class="header-anchor" href="#优点-1"><span>优点</span></a></h3><ul><li>redis 保证数据可持久，本地缓存保证超高的读取性能，微服务共用 redis 大缓存的场景能有效降低 redis 压力</li><li>guava 作为本地缓存，提供了丰富的 api，过期策略，最大容量，保证服务内存可控，冷数据不会长期占据内存空间</li><li>服务重启导致的本地缓存清空不会影响业务进行</li><li>微服务及分布式场景使用，分布式情况下每个服务实例只会缓存自己接入的那一部分设备的自增号，本地内存空间最优</li><li>在示例业务中，自增数满足了分布区发送的均匀分布需求，也可以满足统计设备接入数目的业务场景，一举两得</li></ul><h3 id="缺点-1" tabindex="-1"><a class="header-anchor" href="#缺点-1"><span>缺点</span></a></h3><ul><li>增加编码复杂度，不直接</li><li>只适用于缓存内容只增不改的场景</li></ul><h3 id="总结-1" tabindex="-1"><a class="header-anchor" href="#总结-1"><span>总结</span></a></h3><ul><li>本地缓存空间可控，过期策略优</li><li>适用于微服务及分布式场景</li><li>缓存内容不能发生改变</li><li>性能优</li></ul><h2 id="后记" tabindex="-1"><a class="header-anchor" href="#后记"><span>后记</span></a></h2><p>redis 提供了丰富的数据类型及 api，非常适合业务系统开发，统计计数（increment，decrement），标记位（bitmap）,松散数据（hash）,先进先出、队列式读取（list）；guava 缓存作为本地缓存，能够高效的读取的同时，提供了大量 api 方便我们控制本地缓存的数据量及冷数据淘汰；我们充分的学习这些特性能够帮助我们在业务开发中更加轻松灵活，在空间与时间上找到一个平衡点。</p>`,10);function k(m,v){const e=p("ExternalLinkIcon");return c(),i("div",null,[u,n("p",null,[s("在流处数处理过程中，微服务对多个设备上传的数据进行处理，每个设备有一个 code,流数据的频率高，在消息队列发送过程中使用分区发送，我们需要为设备 code 生成对应的自增号，用自增号对 kafka 中 topic 分区数进行取模，这样如果有 10000 台设备，自增号就是 0~ 9999，在取模后就进行分区发送就可以做到每个分区均匀分布，这个自增号我们使用 redis 的自增数生成，生成后放到 redis 的 hash 结构进行缓存，每次来一个设备，我们就去这个 hash 缓存中取，没有取到就使用自增数生成一个，然后放到 redis 的 hash 缓存中，这时候每个设备的自增数一经生成是不会再发生改变的，我们就想到使用本地缓存进行优化，避免高频的调用 redis 去获取，降低 redis 压力，下面链接为我写的关于 kafka 分区消费的文章，大家可以去看看 "),n("a",d,[s("Kafka 分区发送及消费实战"),l(e)])]),r])}const g=t(o,[["render",k],["__file","Redis与Guava本地缓存组合.html.vue"]]),x=JSON.parse('{"path":"/dev/Redis%E4%B8%8EGuava%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E7%BB%84%E5%90%88.html","title":"Redis与Guava本地缓存组合","lang":"zh-CN","frontmatter":{"author":"xlc520","title":"Redis与Guava本地缓存组合","excerpt":null,"description":"Redis 与 Guava 本地缓存组合 Redis与本地缓存组合Redis与本地缓存组合 前言 我们开发中经常用到 Redis 作为缓存，将高频数据放在 Redis 中能够提高业务性能，降低 MySQL 等关系型数据库压力，甚至一些系统使用 Redis 进行数据持久化，Redis 松散的文档结构非常适合业务系统开发，在精确查询，数据统计业务有着很大的...","date":"2023-01-24T00:00:00.000Z","category":"Java","tag":["Java","Redis","Guava"],"article":true,"timeline":true,"icon":"java","head":[["meta",{"property":"og:url","content":"https://blog.ciberviler.top/dev/Redis%E4%B8%8EGuava%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E7%BB%84%E5%90%88.html"}],["meta",{"property":"og:site_name","content":"StudyNote - 丰富的知识笔记库"}],["meta",{"property":"og:title","content":"Redis与Guava本地缓存组合"}],["meta",{"property":"og:description","content":"Redis 与 Guava 本地缓存组合 Redis与本地缓存组合Redis与本地缓存组合 前言 我们开发中经常用到 Redis 作为缓存，将高频数据放在 Redis 中能够提高业务性能，降低 MySQL 等关系型数据库压力，甚至一些系统使用 Redis 进行数据持久化，Redis 松散的文档结构非常适合业务系统开发，在精确查询，数据统计业务有着很大的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://bitbucket.org/xlc520/blogasset/raw/main/images3/98d8c80f6ae24256832ae271c74d81f2tplv-k3u1fbpfcp-zoom-crop-mark3024302430241702.webp"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-27T13:32:36.000Z"}],["meta",{"property":"article:author","content":"xlc520"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:tag","content":"Guava"}],["meta",{"property":"article:published_time","content":"2023-01-24T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-27T13:32:36.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis与Guava本地缓存组合\\",\\"image\\":[\\"https://bitbucket.org/xlc520/blogasset/raw/main/images3/98d8c80f6ae24256832ae271c74d81f2tplv-k3u1fbpfcp-zoom-crop-mark3024302430241702.webp\\",\\"https://bitbucket.org/xlc520/blogasset/raw/main/images3/98a4b375d0444e589b217a94065219aatplv-k3u1fbpfcp-zoom-in-crop-mark4536000.png\\",\\"https://bitbucket.org/xlc520/blogasset/raw/main/images3/1028922154004ccc9c2811c75325efdctplv-k3u1fbpfcp-zoom-in-crop-mark4536000.png\\"],\\"datePublished\\":\\"2023-01-24T00:00:00.000Z\\",\\"dateModified\\":\\"2024-04-27T13:32:36.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xlc520\\"}]}"]]},"headers":[{"level":2,"title":"前言","slug":"前言","link":"#前言","children":[]},{"level":2,"title":"设计示例","slug":"设计示例","link":"#设计示例","children":[]},{"level":2,"title":"Redis 懒加载缓存","slug":"redis-懒加载缓存","link":"#redis-懒加载缓存","children":[{"level":3,"title":"流程图","slug":"流程图","link":"#流程图","children":[]},{"level":3,"title":"代码示例","slug":"代码示例","link":"#代码示例","children":[]},{"level":3,"title":"优点","slug":"优点","link":"#优点","children":[]},{"level":3,"title":"缺点","slug":"缺点","link":"#缺点","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}]},{"level":2,"title":"Redis 结合本地缓存","slug":"redis-结合本地缓存","link":"#redis-结合本地缓存","children":[{"level":3,"title":"流程图","slug":"流程图-1","link":"#流程图-1","children":[]},{"level":3,"title":"业务场景","slug":"业务场景","link":"#业务场景","children":[]},{"level":3,"title":"代码示例","slug":"代码示例-1","link":"#代码示例-1","children":[]},{"level":3,"title":"优点","slug":"优点-1","link":"#优点-1","children":[]},{"level":3,"title":"缺点","slug":"缺点-1","link":"#缺点-1","children":[]},{"level":3,"title":"总结","slug":"总结-1","link":"#总结-1","children":[]}]},{"level":2,"title":"后记","slug":"后记","link":"#后记","children":[]}],"git":{"createdTime":1674630842000,"updatedTime":1714224756000,"contributors":[{"name":"xlc520","email":"2215400217@qq.com","commits":4},{"name":"xlc","email":"2215400217@qq.com","commits":2}]},"readingTime":{"minutes":6.51,"words":1953},"filePathRelative":"dev/Redis与Guava本地缓存组合.md","localizedDate":"2023年1月24日","autoDesc":true}');export{g as comp,x as data};
