const l=JSON.parse('{"key":"v-358ae550","path":"/dev/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html","title":"JUC并发编程","lang":"zh-CN","frontmatter":{"author":"xlc520","title":"JUC并发编程","description":"一、线程基础 1、Java多线程相关概念 1、进程 是程序的⼀次执⾏，是系统进⾏资源分配和调度的独⽴单位，每⼀个进程都有它⾃⼰的内存空间和系统资源","date":"2022-08-14T00:00:00.000Z","category":"Java","tag":"Java","article":true,"timeline":true,"icon":"java","head":[["meta",{"property":"og:url","content":"https://blog.ciberviler.top/dev/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html"}],["meta",{"property":"og:site_name","content":"StudyNote"}],["meta",{"property":"og:title","content":"JUC并发编程"}],["meta",{"property":"og:description","content":"一、线程基础 1、Java多线程相关概念 1、进程 是程序的⼀次执⾏，是系统进⾏资源分配和调度的独⽴单位，每⼀个进程都有它⾃⼰的内存空间和系统资源"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-08-01T15:10:28.000Z"}],["meta",{"property":"article:author","content":"xlc520"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:published_time","content":"2022-08-14T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-08-01T15:10:28.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JUC并发编程\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-08-14T00:00:00.000Z\\",\\"dateModified\\":\\"2023-08-01T15:10:28.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xlc520\\"}]}"]]},"headers":[{"level":2,"title":"一、线程基础","slug":"一、线程基础","link":"#一、线程基础","children":[{"level":3,"title":"1、Java多线程相关概念","slug":"_1、java多线程相关概念","link":"#_1、java多线程相关概念","children":[]},{"level":3,"title":"2、线程的基本操作","slug":"_2、线程的基本操作","link":"#_2、线程的基本操作","children":[]},{"level":3,"title":"2、为什么多线程极其重要？？？","slug":"_2、为什么多线程极其重要","link":"#_2、为什么多线程极其重要","children":[]},{"level":3,"title":"3、从start一个线程说起","slug":"_3、从start一个线程说起","link":"#_3、从start一个线程说起","children":[]},{"level":3,"title":"4、用户线程和守护线程","slug":"_4、用户线程和守护线程","link":"#_4、用户线程和守护线程","children":[]},{"level":3,"title":"5、获得多线程的方法几种？","slug":"_5、获得多线程的方法几种","link":"#_5、获得多线程的方法几种","children":[]},{"level":3,"title":"6、Callable接口","slug":"_6、callable接口","link":"#_6、callable接口","children":[]}]},{"level":2,"title":"二、线程池","slug":"二、线程池","link":"#二、线程池","children":[{"level":3,"title":"1、什么是线程池","slug":"_1、什么是线程池","link":"#_1、什么是线程池","children":[]},{"level":3,"title":"2、为什么用线程池","slug":"_2、为什么用线程池","link":"#_2、为什么用线程池","children":[]},{"level":3,"title":"3、线程池的使用","slug":"_3、线程池的使用","link":"#_3、线程池的使用","children":[]},{"level":3,"title":"4、ThreadPoolExecutor底层原理","slug":"_4、threadpoolexecutor底层原理","link":"#_4、threadpoolexecutor底层原理","children":[]},{"level":3,"title":"5、拒绝策略？生产中如设置合理参数","slug":"_5、拒绝策略-生产中如设置合理参数","link":"#_5、拒绝策略-生产中如设置合理参数","children":[]},{"level":3,"title":"6、超级大坑 在工作中单一的/固定数的/可变的三种创建线程池的方法哪个用的多？","slug":"_6、超级大坑-在工作中单一的-固定数的-可变的三种创建线程池的方法哪个用的多","link":"#_6、超级大坑-在工作中单一的-固定数的-可变的三种创建线程池的方法哪个用的多","children":[]},{"level":3,"title":"7、自定义线程池","slug":"_7、自定义线程池","link":"#_7、自定义线程池","children":[]},{"level":3,"title":"8、线程池中的2个关闭方法","slug":"_8、线程池中的2个关闭方法","link":"#_8、线程池中的2个关闭方法","children":[]},{"level":3,"title":"9、BlockingQueue阻塞队列","slug":"_9、blockingqueue阻塞队列","link":"#_9、blockingqueue阻塞队列","children":[]},{"level":3,"title":"10、扩展线程池","slug":"_10、扩展线程池","link":"#_10、扩展线程池","children":[]}]},{"level":2,"title":"三、CompletableFuture","slug":"三、completablefuture","link":"#三、completablefuture","children":[{"level":3,"title":"1、Future和Callable接口","slug":"_1、future和callable接口","link":"#_1、future和callable接口","children":[]},{"level":3,"title":"2、从之前的FutureTask开始","slug":"_2、从之前的futuretask开始","link":"#_2、从之前的futuretask开始","children":[]},{"level":3,"title":"3、对Future的改进","slug":"_3、对future的改进","link":"#_3、对future的改进","children":[]},{"level":3,"title":"4、核心的四个静态方法","slug":"_4、核心的四个静态方法","link":"#_4、核心的四个静态方法","children":[]},{"level":3,"title":"5、join和get对比","slug":"_5、join和get对比","link":"#_5、join和get对比","children":[]},{"level":3,"title":"6、案例精讲-从电商网站的比价需求说开去","slug":"_6、案例精讲-从电商网站的比价需求说开去","link":"#_6、案例精讲-从电商网站的比价需求说开去","children":[]},{"level":3,"title":"7、CompletableFuture常用方法","slug":"_7、completablefuture常用方法","link":"#_7、completablefuture常用方法","children":[]},{"level":3,"title":"8、分支合并框架","slug":"_8、分支合并框架","link":"#_8、分支合并框架","children":[]}]},{"level":2,"title":"四、Java“锁”事","slug":"四、java-锁-事","link":"#四、java-锁-事","children":[{"level":3,"title":"1、Lock","slug":"_1、lock","link":"#_1、lock","children":[]},{"level":3,"title":"2、synchronized与Lock的区别","slug":"_2、synchronized与lock的区别","link":"#_2、synchronized与lock的区别","children":[]},{"level":3,"title":"3、synchronized","slug":"_3、synchronized","link":"#_3、synchronized","children":[]},{"level":3,"title":"4、ReentrantLock","slug":"_4、reentrantlock","link":"#_4、reentrantlock","children":[]},{"level":3,"title":"5、悲观锁","slug":"_5、悲观锁","link":"#_5、悲观锁","children":[]},{"level":3,"title":"6、乐观锁","slug":"_6、乐观锁","link":"#_6、乐观锁","children":[]},{"level":3,"title":"7、八锁案例","slug":"_7、八锁案例","link":"#_7、八锁案例","children":[]},{"level":3,"title":"8、公平锁和非公平锁","slug":"_8、公平锁和非公平锁","link":"#_8、公平锁和非公平锁","children":[]},{"level":3,"title":"9、可重入锁(又名递归锁)","slug":"_9、可重入锁-又名递归锁","link":"#_9、可重入锁-又名递归锁","children":[]},{"level":3,"title":"10、死锁","slug":"_10、死锁","link":"#_10、死锁","children":[]}]},{"level":2,"title":"五、线程间通信","slug":"五、线程间通信","link":"#五、线程间通信","children":[{"level":3,"title":"1、面试题：两个线程打印","slug":"_1、面试题-两个线程打印","link":"#_1、面试题-两个线程打印","children":[]},{"level":3,"title":"2、线程间定制化调用通信","slug":"_2、线程间定制化调用通信","link":"#_2、线程间定制化调用通信","children":[]}]},{"level":2,"title":"六、LockSupport与线程中断","slug":"六、locksupport与线程中断","link":"#六、locksupport与线程中断","children":[{"level":3,"title":"1、线程中断机制","slug":"_1、线程中断机制","link":"#_1、线程中断机制","children":[]},{"level":3,"title":"2、如何使用中断标识停止线程？","slug":"_2、如何使用中断标识停止线程","link":"#_2、如何使用中断标识停止线程","children":[]},{"level":3,"title":"3、LockSupport是什么","slug":"_3、locksupport是什么","link":"#_3、locksupport是什么","children":[]},{"level":3,"title":"4、线程等待唤醒机制","slug":"_4、线程等待唤醒机制","link":"#_4、线程等待唤醒机制","children":[]}]},{"level":2,"title":"七、集合不安全","slug":"七、集合不安全","link":"#七、集合不安全","children":[{"level":3,"title":"1、线程不安全错误","slug":"_1、线程不安全错误","link":"#_1、线程不安全错误","children":[]},{"level":3,"title":"2、List不安全","slug":"_2、list不安全","link":"#_2、list不安全","children":[]},{"level":3,"title":"3、Set不安全","slug":"_3、set不安全","link":"#_3、set不安全","children":[]},{"level":3,"title":"4、Map不安全","slug":"_4、map不安全","link":"#_4、map不安全","children":[]}]},{"level":2,"title":"八、JUC强大的辅助类","slug":"八、juc强大的辅助类","link":"#八、juc强大的辅助类","children":[{"level":3,"title":"1、CountDownLatch减少计数","slug":"_1、countdownlatch减少计数","link":"#_1、countdownlatch减少计数","children":[]},{"level":3,"title":"2、CyclicBarrier循环栅栏","slug":"_2、cyclicbarrier循环栅栏","link":"#_2、cyclicbarrier循环栅栏","children":[]},{"level":3,"title":"3、Semaphore信号灯","slug":"_3、semaphore信号灯","link":"#_3、semaphore信号灯","children":[]}]},{"level":2,"title":"九、Java内存模型之JMM","slug":"九、java内存模型之jmm","link":"#九、java内存模型之jmm","children":[{"level":3,"title":"1、计算机硬件存储体系","slug":"_1、计算机硬件存储体系","link":"#_1、计算机硬件存储体系","children":[]},{"level":3,"title":"2、Java内存模型Java Memory Model","slug":"_2、java内存模型java-memory-model","link":"#_2、java内存模型java-memory-model","children":[]},{"level":3,"title":"3、JMM规范下，三大特性","slug":"_3、jmm规范下-三大特性","link":"#_3、jmm规范下-三大特性","children":[]},{"level":3,"title":"4、JMM规范下，多线程对变量的读写过程","slug":"_4、jmm规范下-多线程对变量的读写过程","link":"#_4、jmm规范下-多线程对变量的读写过程","children":[]},{"level":3,"title":"5、JMM规范下，多线程先行发生原则之happens-before","slug":"_5、jmm规范下-多线程先行发生原则之happens-before","link":"#_5、jmm规范下-多线程先行发生原则之happens-before","children":[]},{"level":3,"title":"6、happens-before之8条","slug":"_6、happens-before之8条","link":"#_6、happens-before之8条","children":[]},{"level":3,"title":"7、案例说明","slug":"_7、案例说明","link":"#_7、案例说明","children":[]}]},{"level":2,"title":"十、volatile与Java内存模型","slug":"十、volatile与java内存模型","link":"#十、volatile与java内存模型","children":[{"level":3,"title":"1、被volatile修改的变量有2大特点","slug":"_1、被volatile修改的变量有2大特点","link":"#_1、被volatile修改的变量有2大特点","children":[]},{"level":3,"title":"2、volatile的内存语义","slug":"_2、volatile的内存语义","link":"#_2、volatile的内存语义","children":[]},{"level":3,"title":"3、内存屏障（重点）","slug":"_3、内存屏障-重点","link":"#_3、内存屏障-重点","children":[]},{"level":3,"title":"4、volatile特性","slug":"_4、volatile特性","link":"#_4、volatile特性","children":[]}]},{"level":2,"title":"十一、CAS","slug":"十一、cas","link":"#十一、cas","children":[{"level":3,"title":"1、没有CAS之前","slug":"_1、没有cas之前","link":"#_1、没有cas之前","children":[]},{"level":3,"title":"2、CAS是什么","slug":"_2、cas是什么","link":"#_2、cas是什么","children":[]},{"level":3,"title":"3、CAS底层原理？如果知道，谈谈你对UnSafe的理解","slug":"_3、cas底层原理-如果知道-谈谈你对unsafe的理解","link":"#_3、cas底层原理-如果知道-谈谈你对unsafe的理解","children":[]},{"level":3,"title":"4、原子引用","slug":"_4、原子引用","link":"#_4、原子引用","children":[]},{"level":3,"title":"5、自旋锁，借鉴CAS思想","slug":"_5、自旋锁-借鉴cas思想","link":"#_5、自旋锁-借鉴cas思想","children":[]},{"level":3,"title":"6、CAS缺点","slug":"_6、cas缺点","link":"#_6、cas缺点","children":[]}]},{"level":2,"title":"十二、原子操作类之18罗汉增强","slug":"十二、原子操作类之18罗汉增强","link":"#十二、原子操作类之18罗汉增强","children":[{"level":3,"title":"1、基本类型原子类","slug":"_1、基本类型原子类","link":"#_1、基本类型原子类","children":[]},{"level":3,"title":"2、数组类型原子类","slug":"_2、数组类型原子类","link":"#_2、数组类型原子类","children":[]},{"level":3,"title":"3、引用类型原子类","slug":"_3、引用类型原子类","link":"#_3、引用类型原子类","children":[]},{"level":3,"title":"4、对象的属性修改原子类","slug":"_4、对象的属性修改原子类","link":"#_4、对象的属性修改原子类","children":[]},{"level":3,"title":"5、你在哪里用了volatile","slug":"_5、你在哪里用了volatile","link":"#_5、你在哪里用了volatile","children":[]},{"level":3,"title":"6、原子操作增强类原理深度解析","slug":"_6、原子操作增强类原理深度解析","link":"#_6、原子操作增强类原理深度解析","children":[]},{"level":3,"title":"7、总结","slug":"_7、总结-1","link":"#_7、总结-1","children":[]}]},{"level":2,"title":"十三、ThreadLocal、InheritableThreadLocal","slug":"十三、threadlocal、inheritablethreadlocal","link":"#十三、threadlocal、inheritablethreadlocal","children":[{"level":3,"title":"1、ThreadLocal简介","slug":"_1、threadlocal简介","link":"#_1、threadlocal简介","children":[]},{"level":3,"title":"2、永远的helloworld","slug":"_2、永远的helloworld","link":"#_2、永远的helloworld","children":[]},{"level":3,"title":"3、从阿里ThreadLocal规范开始","slug":"_3、从阿里threadlocal规范开始","link":"#_3、从阿里threadlocal规范开始","children":[]},{"level":3,"title":"4、ThreadLocal源码分析","slug":"_4、threadlocal源码分析","link":"#_4、threadlocal源码分析","children":[]},{"level":3,"title":"5、ThreadLocal内存泄露问题","slug":"_5、threadlocal内存泄露问题","link":"#_5、threadlocal内存泄露问题","children":[]},{"level":3,"title":"6、为什么要用弱引用?不用如何？","slug":"_6、为什么要用弱引用-不用如何","link":"#_6、为什么要用弱引用-不用如何","children":[]},{"level":3,"title":"7、最佳实践","slug":"_7、最佳实践","link":"#_7、最佳实践","children":[]},{"level":3,"title":"8、小总结","slug":"_8、小总结","link":"#_8、小总结","children":[]},{"level":3,"title":"9、ThreadLocal和InheritableThreadLocal","slug":"_9、threadlocal和inheritablethreadlocal","link":"#_9、threadlocal和inheritablethreadlocal","children":[]}]},{"level":2,"title":"十四、Java对象内存布局和对象头","slug":"十四、java对象内存布局和对象头","link":"#十四、java对象内存布局和对象头","children":[{"level":3,"title":"1、对象在堆内存中布局","slug":"_1、对象在堆内存中布局","link":"#_1、对象在堆内存中布局","children":[]},{"level":3,"title":"2、MarkWord","slug":"_2、markword","link":"#_2、markword","children":[]},{"level":3,"title":"3、聊聊Object obj = new Object()","slug":"_3、聊聊object-obj-new-object","link":"#_3、聊聊object-obj-new-object","children":[]},{"level":3,"title":"4、换成其他对象试试","slug":"_4、换成其他对象试试","link":"#_4、换成其他对象试试","children":[]}]},{"level":2,"title":"十五、Synchronized与锁升级","slug":"十五、synchronized与锁升级","link":"#十五、synchronized与锁升级","children":[{"level":3,"title":"1、Synchronized 锁优化的背景","slug":"_1、synchronized-锁优化的背景","link":"#_1、synchronized-锁优化的背景","children":[]},{"level":3,"title":"2、Synchronized的性能变化","slug":"_2、synchronized的性能变化","link":"#_2、synchronized的性能变化","children":[]},{"level":3,"title":"3、Synchronized锁种类及升级步骤","slug":"_3、synchronized锁种类及升级步骤","link":"#_3、synchronized锁种类及升级步骤","children":[]},{"level":3,"title":"4、JIT编译器对锁的优化","slug":"_4、jit编译器对锁的优化","link":"#_4、jit编译器对锁的优化","children":[]}]},{"level":2,"title":"十六、AbstractQueuedSynchronizer之AQS","slug":"十六、abstractqueuedsynchronizer之aqs","link":"#十六、abstractqueuedsynchronizer之aqs","children":[{"level":3,"title":"1、AQS是什么","slug":"_1、aqs是什么","link":"#_1、aqs是什么","children":[]},{"level":3,"title":"2、AQS为什么是JUC内容中最重要的基石","slug":"_2、aqs为什么是juc内容中最重要的基石","link":"#_2、aqs为什么是juc内容中最重要的基石","children":[]},{"level":3,"title":"3、AQS能干嘛","slug":"_3、aqs能干嘛","link":"#_3、aqs能干嘛","children":[]},{"level":3,"title":"4、AQS初步","slug":"_4、aqs初步","link":"#_4、aqs初步","children":[]},{"level":3,"title":"5、从ReentrantLock开始解读AQS","slug":"_5、从reentrantlock开始解读aqs","link":"#_5、从reentrantlock开始解读aqs","children":[]}]},{"level":2,"title":"十七、ReentrantLock、ReentrantReadWriteLock、StampedLock","slug":"十七、reentrantlock、reentrantreadwritelock、stampedlock","link":"#十七、reentrantlock、reentrantreadwritelock、stampedlock","children":[{"level":3,"title":"1、ReentrantReadWriteLock","slug":"_1、reentrantreadwritelock","link":"#_1、reentrantreadwritelock","children":[]},{"level":3,"title":"2、邮戳锁StampedLock","slug":"_2、邮戳锁stampedlock","link":"#_2、邮戳锁stampedlock","children":[]}]}],"git":{"createdTime":1668948234000,"updatedTime":1690902628000,"contributors":[{"name":"xlc520","email":"2215400217@qq.com","commits":4}]},"readingTime":{"minutes":260.74,"words":78222},"filePathRelative":"dev/JUC并发编程.md","localizedDate":"2022年8月14日","excerpt":"<h2> 一、线程基础</h2>\\n<h3> 1、Java多线程相关概念</h3>\\n<h4> 1、进程</h4>\\n<p>是程序的⼀次执⾏，是系统进⾏资源分配和调度的独⽴单位，每⼀个进程都有它⾃⼰的内存空间和系统资源</p>","autoDesc":true}');export{l as data};
