import{_ as i}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as t,a as e}from"./app-V68d0221.js";const l={},r=e(`<h1 id="spring-boot-企业规范" tabindex="-1"><a class="header-anchor" href="#spring-boot-企业规范" aria-hidden="true">#</a> Spring Boot 企业规范</h1><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Spring Boot 是一种广泛使用且非常流行的企业级高性能框架。以下是一些最佳实践和一些技巧，我们可以使用它们来改进 Spring Boot 应用程序并使其更加高效。这篇文章会有点长，完整读完文章需要一些时间。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_1、正确的包目录风格" tabindex="-1"><a class="header-anchor" href="#_1、正确的包目录风格" aria-hidden="true">#</a> <strong>1、正确的包目录风格</strong></h3><ul><li>正确的包目录将有助于轻松理解代码和应用程序的流程。</li><li>我们可以使用有意义的包目录来构建我们的应用程序。</li><li>我们可以将所有控制器包含在单独的包中，将服务包含在单独的包中，将 util 类包含在单独的包中等等。这种风格在小型微服务中非常方便。</li><li>如果我们正在处理庞大的代码库，则可以使用基于功能模块的方法。我们可以根据我们的要求来决定。</li></ul><h5 id="基于类型" tabindex="-1"><a class="header-anchor" href="#基于类型" aria-hidden="true">#</a> 基于类型</h5><figure><img src="https://static.xlc520.tk/blogImage/640-1700667020609-0.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h5 id="基于功能模块" tabindex="-1"><a class="header-anchor" href="#基于功能模块" aria-hidden="true">#</a> <strong>基于功能模块</strong></h5><figure><img src="https://static.xlc520.tk/blogImage/640-1700829446082-1.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h3 id="_2、使用设计模式" tabindex="-1"><a class="header-anchor" href="#_2、使用设计模式" aria-hidden="true">#</a> <strong>2、使用设计模式</strong></h3><p>没什么好说的，设计模式已经是现代编程中编写可维护、可扩展代码的最佳实践。</p><h3 id="_3、使用-spring-boot-starter" tabindex="-1"><a class="header-anchor" href="#_3、使用-spring-boot-starter" aria-hidden="true">#</a> <strong>3、使用 Spring Boot starter</strong></h3><p>这是 Spring Boot 的一个很酷的功能。</p><p>我们可以非常轻松地使用启动器依赖项，而无需一一添加单个依赖项。这些入门依赖项已与所需的依赖项捆绑在一起。</p><p>例如，如果我们添加 spring-boot-starter-web 依赖项，默认情况下它会与 jackson、spring-core、spring-mvc 和 spring-boot-starter-tomcat 依赖项捆绑在一起。</p><p>所以我们不需要关心单独添加依赖项。</p><p>它还可以帮助我们避免版本不匹配。</p><h3 id="_4、使用生产版本的依赖项" tabindex="-1"><a class="header-anchor" href="#_4、使用生产版本的依赖项" aria-hidden="true">#</a> <strong>4、使用生产版本的依赖项</strong></h3><p>始终建议使用最新的稳定 GA 版本。</p><p>有时它可能会因 Java 版本、服务器版本、应用程序类型等而有所不同。</p><p>不要使用同一包的不同版本，如果存在多个依赖项，请始终使用<code>&lt;properties&gt;</code>指定版本。</p><figure><img src="https://static.xlc520.tk/blogImage/640-1700829446083-2.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h3 id="_5、使用-lombok" tabindex="-1"><a class="header-anchor" href="#_5、使用-lombok" aria-hidden="true">#</a> <strong>5、使用 Lombok</strong></h3><p>作为一名 Java 开发人员，我们可能听说过 Lombok 项目。</p><p>Lombok 是一个 Java 库，可用于减少代码并允许我们使用其注释编写干净的代码。</p><p>例如，我们可能在某些类（如实体、请求/响应对象、dtos 等）中使用大量的 getter 和 setter 行。</p><p>但如果你使用 Lombok，它只是一行，你可以根据你的要求使用@Data、@Getter 或@Setter。</p><p>我们也可以使用 Lombok 记录器注释。推荐@Slf4j。</p><p>检查此文件以供参考。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>2024最新架构课程，对标培训机构
👉点击查看：Java成神之路-进阶架构视频！
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_6、将构造函数注入与-lombok-一起使用" tabindex="-1"><a class="header-anchor" href="#_6、将构造函数注入与-lombok-一起使用" aria-hidden="true">#</a> <strong>6、将构造函数注入与 Lombok 一起使用</strong></h3><figure><img src="https://static.xlc520.tk/blogImage/640-1700829446083-3.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>当我们谈论依赖注入时，有两种类型。</p><p>一种是“构造函数注入”，另一种是“setter 注入”。除此之外，我们还可以使用非常流行的@Autowired 注释来使用“字段注入”。</p><p>但我们强烈建议使用构造函数注入而不是其他类型。因为它允许应用程序在初始化时初始化所有必需的依赖项。</p><p>这对于单元测试非常有用。</p><p>重要的是，我们可以使用 Lombok 的 @RequiredArgsConstructor 注释来使用构造函数注入。</p><p>检查此示例控制器以供参考。</p><h3 id="_7、使用-slf4j-日志" tabindex="-1"><a class="header-anchor" href="#_7、使用-slf4j-日志" aria-hidden="true">#</a> <strong>7、使用 slf4j 日志</strong></h3><figure><img src="https://static.xlc520.tk/blogImage/640-1700829446083-4.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><ul><li>日志记录非常重要。</li><li>如果我们的应用程序在生产过程中出现问题，日志记录是找出根本原因的唯一方法。</li><li>因此，在添加记录器、日志消息类型、记录器级别和记录器消息之前应该仔细考虑。</li><li>不要使用 System.out.print()</li><li>建议将 Slf4j 与 Spring Boot 中默认的日志框架 logback 一起使用。</li><li>始终使用 slf4j 的 {} 占位符语法，避免在记录器消息中使用字符串插值。因为字符串插值会消耗更多的内存。</li><li>我们可以使用 Lombok @Slf4j 注释非常轻松地创建日志记录器。</li><li>如果我们处于微服务环境中，则可以使用 ELK 技术栈。</li></ul><h3 id="_8、控制器仅用于路由" tabindex="-1"><a class="header-anchor" href="#_8、控制器仅用于路由" aria-hidden="true">#</a> <strong>8、控制器仅用于路由</strong></h3><figure><img src="https://static.xlc520.tk/blogImage/640-1700829446083-5.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><ul><li>控制器专用于路由。</li><li>它是无状态且单身的。</li><li>DispatcherServlet 将检查控制器上的 @RequestMapping</li><li>控制器是请求的最终目标，请求将交给服务层并由服务层处理。</li><li>业务逻辑不应位于控制器中。</li></ul><h3 id="_9、使用service来实现业务逻辑" tabindex="-1"><a class="header-anchor" href="#_9、使用service来实现业务逻辑" aria-hidden="true">#</a> <strong>9、使用Service来实现业务逻辑</strong></h3><ul><li>完整的业务逻辑包含验证、缓存等。</li><li>与持久层通信并接收结果。</li><li>Service也是单例的。</li></ul><h3 id="_10、避免空指针异常" tabindex="-1"><a class="header-anchor" href="#_10、避免空指针异常" aria-hidden="true">#</a> <strong>10、避免空指针异常</strong></h3><figure><img src="https://static.xlc520.tk/blogImage/640-1700829446083-6.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><ul><li>为了避免 NullPointerException，我们可以使用 java.util 包中的 Optional。</li><li>我们还可以使用空安全库。例如：Apache Commons StringUtils</li><li>对已知对象调用 equals() 和 equalsIgnoreCase() 方法。</li><li>使用 valueOf() 而不是 toString()</li><li>使用基于 IDE 的 @NotNull 和 @Nullable 注释。</li></ul><h3 id="_11、使用集合框架的最佳实践" tabindex="-1"><a class="header-anchor" href="#_11、使用集合框架的最佳实践" aria-hidden="true">#</a> <strong>11、使用集合框架的最佳实践</strong></h3><ul><li>对我们的数据集使用适当的集合。</li><li>将 forEach 与 Java 8 功能结合使用，并避免使用旧版 for 循环。</li><li>使用接口类型而不是实现。</li><li>使用 isEmpty() 而不是 size() 以获得更好的可读性。</li><li>不返回空值，可以返回空集合。</li><li>如果我们使用对象作为要存储在基于哈希的集合中的数据，则应重写 equals() 和 hashCode() 方法。请查看这篇文章“HashMap 内部是如何工作的”。</li></ul><h3 id="_12、使用分页" tabindex="-1"><a class="header-anchor" href="#_12、使用分页" aria-hidden="true">#</a> <strong>12、使用分页</strong></h3><figure><img src="https://static.xlc520.tk/blogImage/640-1700829446083-7.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>这将提高应用程序的性能。</p><p>如果我们使用 Spring Data JPA，则 PagingAndSortingRepository 使分页的使用变得非常容易且几乎不费吹灰之力。</p><h3 id="_13、使用缓存" tabindex="-1"><a class="header-anchor" href="#_13、使用缓存" aria-hidden="true">#</a> <strong>13、使用缓存</strong></h3><p>在谈论应用程序性能时，缓存是另一个重要因素。</p><p>默认情况下，Spring Boot 通过 ConcurrentHashMap 提供缓存，我们可以通过 @EnableCaching 注解来实现这一点。如果我们对默认缓存不满意，可以使用 Redis、Hazelcast 或任何其他分布式缓存实现。</p><p>Redis 和 Hazelcast 是内存缓存方法。我们还可以使用数据库缓存实现。</p><h3 id="_14、使用自定义异常处理程序和全局异常处理" tabindex="-1"><a class="header-anchor" href="#_14、使用自定义异常处理程序和全局异常处理" aria-hidden="true">#</a> <strong>14、使用自定义异常处理程序和全局异常处理</strong></h3><ul><li>这在使用大型企业级应用程序时非常重要。</li><li>除了一般异常之外，我们可能还会有一些场景来识别某些特定的错误情况。</li><li>异常顾问可以使用@ControllerAdvice 创建，我们可以创建具有有意义细节的单独异常。</li><li>它将使得将来识别和调试错误变得更加容易。</li></ul><h3 id="_15、使用自定义响应对象" tabindex="-1"><a class="header-anchor" href="#_15、使用自定义响应对象" aria-hidden="true">#</a> <strong>15、使用自定义响应对象</strong></h3><figure><img src="https://static.xlc520.tk/blogImage/640-1700829446083-8.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><ul><li>自定义响应对象可用于返回包含某些特定数据的对象，并满足 HTTP 状态代码、API 代码、消息等要求。</li><li>我们可以使用构建器设计模式来创建具有自定义属性的自定义响应对象。</li></ul><h3 id="_16、删除不必要的代码、变量、方法和类。" tabindex="-1"><a class="header-anchor" href="#_16、删除不必要的代码、变量、方法和类。" aria-hidden="true">#</a> <strong>16、删除不必要的代码、变量、方法和类。</strong></h3><figure><img src="https://static.xlc520.tk/blogImage/640-1700829446084-9.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><ul><li>未使用的变量声明将占用一些内存。</li><li>删除未使用的方法、类等，因为它会影响应用程序的性能。</li><li>尽量避免嵌套循环。我们可以使用map代替。</li></ul><h3 id="_17、使用注释" tabindex="-1"><a class="header-anchor" href="#_17、使用注释" aria-hidden="true">#</a> <strong>17、使用注释</strong></h3><ul><li>注释是一个很好的做法。</li><li>不要对一切代码发表注释。相反，我们可以使用类、函数、方法、变量等有意义的单词编写描述性代码。</li><li>删除注释代码、误导性注释和故事型注释。</li><li>我们可以使用注释进行警告，并解释一些乍一看难以理解的内容。</li></ul><h3 id="_18、对类、方法、函数、变量和其他属性使用有意义的词语。" tabindex="-1"><a class="header-anchor" href="#_18、对类、方法、函数、变量和其他属性使用有意义的词语。" aria-hidden="true">#</a> <strong>18、对类、方法、函数、变量和其他属性使用有意义的词语。</strong></h3><figure><img src="https://static.xlc520.tk/blogImage/640-1700829446084-10.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><ul><li><p>这看起来很简单，但影响却是巨大的。</p></li><li><p>始终使用正确的有意义且可搜索的命名约定以及正确的大小写。</p></li><li><p>通常，我们在声明类、变量和常量时使用名词或短语。例如：字符串 firstName，const isValid</p></li><li><p>我们可以使用带有形容词的动词和短语来表示函数和方法。例如：readFile()、sendData()</p></li><li><p>避免使用缩写变量名和意图揭示的名称。例如：int i;字符串 getExUsr;</p></li><li><p>如果我们有意义地使用此功能，则可以减少声明注释行。由于它具有有意义的名称，新开发人员可以通过阅读代码轻松理解。</p></li></ul><h3 id="_19、使用正确的大小写进行声明" tabindex="-1"><a class="header-anchor" href="#_19、使用正确的大小写进行声明" aria-hidden="true">#</a> <strong>19、使用正确的大小写进行声明</strong></h3><figure><img src="https://static.xlc520.tk/blogImage/640-1700829446084-11.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>有许多不同的大小写，如大写、小写、驼峰命名、帕斯卡命名、蛇命名、大蛇式命名、短横线命名等。</p><p>但我们需要确定哪个案例专用于哪个变量。</p><p>通常，我会遵循，</p><ul><li>类 — 帕斯卡命名</li><li>方法和变量 — 驼峰命名</li><li>常量 — 大蛇式命名</li><li>数据库相关字段 — 短横线命名</li></ul><p>这只是一个例子,它可能与我们在公司遵循的标准不同。</p><h3 id="_20、简单点" tabindex="-1"><a class="header-anchor" href="#_20、简单点" aria-hidden="true">#</a> <strong>20、简单点</strong></h3><ul><li>始终尝试编写简单、可读的代码。</li><li>同样简单的逻辑可以用不同的方式实现，但是如果不可读或不理解就很难理解。</li><li>有时复杂的逻辑会消耗更多的内存。</li><li>编写代码时尝试使用 KISS、DRY 和 SOLID 原则。我将在以后的文章中解释这一点。</li></ul><h3 id="_21、使用通用的代码格式样式" tabindex="-1"><a class="header-anchor" href="#_21、使用通用的代码格式样式" aria-hidden="true">#</a> <strong>21、使用通用的代码格式样式</strong></h3><figure><img src="https://static.xlc520.tk/blogImage/640-1700829446084-12.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><ul><li>格式样式因开发人员而异。编码风格的改变也被认为是一种改变，并且会使代码合并变得非常困难。</li><li>为了避免这种情况，团队可以采用通用的编码格式。</li></ul><h3 id="_22、使用-sonarlint-插件" tabindex="-1"><a class="header-anchor" href="#_22、使用-sonarlint-插件" aria-hidden="true">#</a> <strong>22、使用 SonarLint 插件</strong></h3>`,84),n=[r];function o(s,g){return a(),t("div",null,n)}const c=i(l,[["render",o],["__file","Spring Boot 企业规范.html.vue"]]);export{c as default};
