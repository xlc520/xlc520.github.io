import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,a as l}from"./app-DDjfOKh-.js";const e={};function p(t,n){return s(),a("div",null,n[0]||(n[0]=[l(`<h1 id="腾讯云后端总结的面试-15-问" tabindex="-1"><a class="header-anchor" href="#腾讯云后端总结的面试-15-问"><span>腾讯云后端总结的面试 15 问</span></a></h1><ol><li>聊聊项目，好的设计，好的代码</li><li>谈谈什么是零拷贝？</li><li>一共有几种 IO 模型？NIO 和多路复用的区别？</li><li>Future 实现阻塞等待获取结果的原理？</li><li>ReentrantLock 和 Synchronized 的区别？Synchronized 的原理？</li><li>聊聊 AOS？ReentrantLock 的实现原理？</li><li>乐观锁和悲观锁， 让你来写你怎么实现？</li><li>Paxos 协议了解？工作流程是怎么样的？</li><li>B+树聊一下？B+树是不是有序？B+树和 B-树的主要区别？</li><li>TCP 的拥塞机制</li><li>工作中有过 JVM 实践嘛</li><li>数据库分库分表的缺点是啥？</li><li>分布式事务如何解决？TCC 了解？</li><li>RocketMQ 如何保证消息的准确性和安全性？</li><li>算法题：三个数求和</li></ol><p><strong>1.聊聊项目，好的设计，好的代码</strong>项目的话，你可以聊聊你平时做的项目，尤其有亮点的项目。如果没有什么特别亮点的项目，也可以说说一些好的设计，或者你优化了什么接口，性能提升了多少，优化了什么慢 SQL 都可以。甚至是一些好的代码写法都可以。**2. 谈谈什么是零拷贝？**零拷贝是指计算机执行 IO 操作时，CPU 不需要将数据从一个存储区域复制到另一个存储区域，从而可以减少上下文切换以及 CPU 的拷贝时间。它是一种 I/O 操作优化技术。<strong>传统 IO 的执行流程</strong>传统的 IO 流程，包括 read 和 write 的过程。</p><ul><li>read：把数据从磁盘读取到内核缓冲区，再拷贝到用户缓冲区</li><li>write：先把数据写入到 socket 缓冲区，最后写入网卡设备。</li></ul><figure><img src="https://pic1.zhimg.com/80/v2-4612838075ea362fe4c9d3fb28514af2_720w.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ol><li>用户应用进程调用 read 函数，向操作系统发起 IO 调用，上下文从用户态转为内核态（切换 1）</li><li>DMA 控制器把数据从磁盘中，读取到内核缓冲区。</li><li>CPU 把内核缓冲区数据，拷贝到用户应用缓冲区，上下文从内核态转为用户态（切换 2），read 函数返回</li><li>用户应用进程通过 write 函数，发起 IO 调用，上下文从用户态转为内核态（切换 3）</li><li>CPU 将用户缓冲区中的数据，拷贝到 socket 缓冲区</li><li>DMA 控制器把数据从 socket 缓冲区，拷贝到网卡设备，上下文从内核态切换回用户态（切换 4），write 函数返回</li></ol><p>传统 IO 的读写流程，包括了<strong>4 次上下文切换</strong>（4 次用户态和内核态的切换），<strong>4 次数据拷贝</strong>（两次 CPU 拷贝以及两次的 DMA 拷贝)。<strong>零拷贝实现方式</strong>： 零拷贝并不是没有拷贝数据，而是减少用户态/内核态的切换次数以及 CPU 拷贝的次数。零拷贝一般有这三种实现方式：</p><ul><li>mmap+write</li><li>sendfile</li><li>带有 DMA 收集拷贝功能的 sendfile</li></ul><p><strong>mmap+write</strong>mmap 就是用了虚拟内存这个特点，它将内核中的读缓冲区与用户空间的缓冲区进行映射，以减少数据拷贝次数！</p><figure><img src="https://pic2.zhimg.com/80/v2-7005e4d083f4183c8cbc4e06e46a65bd_720w.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ol><li>用户进程通过 mmap 方法向操作系统内核发起 IO 调用，上下文从用户态切换为内核态。</li><li>CPU 利用 DMA 控制器，把数据从硬盘中拷贝到内核缓冲区。</li><li>上下文从内核态切换回用户态，mmap 方法返回。</li><li>用户进程通过 write 方法向操作系统内核发起 IO 调用，上下文从用户态切换为内核态。</li><li>CPU 将内核缓冲区的数据拷贝到的 socket 缓冲区。</li><li>CPU 利用 DMA 控制器，把数据从 socket 缓冲区拷贝到网卡，上下文从内核态切换回用户态，write 调用返回。</li></ol><p>mmap+write 实现的零拷贝，I/O 发生了 4 次用户空间与内核空间的上下文切换，以及 3 次数据拷贝（包括了 2 次 DMA 拷贝和 1 次 CPU 拷贝）。<strong>sendfile</strong>sendfile 表示在两个文件描述符之间传输数据，它是在操作系统内核中操作的，避免了数据从内核缓冲区和用户缓冲区之间的拷贝操作</p><figure><img src="https://pic3.zhimg.com/80/v2-a255e00d0c3c64807c7fa3de5f90f8e5_720w.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ol><li>用户进程发起 sendfile 系统调用，上下文（切换 1）从用户态转向内核态</li><li>DMA 控制器，把数据从硬盘中拷贝到内核缓冲区。</li><li>CPU 将读缓冲区中数据拷贝到 socket 缓冲区</li><li>DMA 控制器，异步把数据从 socket 缓冲区拷贝到网卡，</li><li>上下文（切换 2）从内核态切换回用户态，sendfile 调用返回。</li></ol><p>sendfile 实现的零拷贝，I/O 发生了 2 次用户空间与内核空间的上下文切换，以及 3 次数据拷贝。其中 3 次数据拷贝中，包括了 2 次 DMA 拷贝和 1 次 CPU 拷贝。<strong>带有 DMA 收集拷贝功能的 sendfile</strong>linux 2.4 版本之后，对 sendfile 做了优化升级，引入 SG-DMA 技术，其实就是对 DMA 拷贝加入了 scatter/gather 操作，它可以直接从内核空间缓冲区中将数据读取到网卡。使用这个特点搞零拷贝，即还可以多省去一次 CPU 拷贝。</p><figure><img src="https://pic1.zhimg.com/80/v2-cc942a7fa9dcc344ba8ab3825474f1e6_720w.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ol><li>用户进程发起 sendfile 系统调用，上下文（切换 1）从用户态转向内核态</li><li>DMA 控制器，把数据从硬盘中拷贝到内核缓冲区。</li><li>CPU 把内核缓冲区中的文件描述符信息（包括内核缓冲区的内存地址和偏移量）发送到 socket 缓冲区</li><li>DMA 控制器根据文件描述符信息，直接把数据从内核缓冲区拷贝到网卡</li><li>上下文（切换 2）从内核态切换回用户态，sendfile 调用返回。</li></ol><p>可以发现，<strong>sendfile+DMA scatter/gather</strong>实现的零拷贝，I/O 发生了 2 次用户空间与内核空间的上下文切换，以及 2 次数据拷贝。其中 2 次数据拷贝都是包 DMA 拷贝。这就是真正的 零拷贝（Zero-copy) 技术，全程都没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。</p><p><strong><a href="https://docs.qq.com/doc/DS0NrU3hybHZlRnRq" target="_blank" rel="noopener noreferrer">点击此处可免费领取更多 Java 面试真题</a></strong></p><p>**3. 一共有几种 IO 模型？NIO 和多路复用的区别？**<strong>一共有五种 IO 模型</strong></p><ul><li>阻塞 IO 模型</li><li>非阻塞 IO 模型</li><li>IO 多路复用模型</li><li>IO 模型之信号驱动模型</li><li>IO 模型之异步 IO(AIO)</li></ul><p>**NIO（非阻塞 IO 模型）**NIO，即 Non-Blocking IO，是非阻塞 IO 模型。非阻塞 IO 的流程如下：</p><figure><img src="https://pic3.zhimg.com/80/v2-5ecab3b6edb0cd59756be08c75113d1f_720w.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ol><li>应用进程向操作系统内核，发起 recvfrom 读取数据。</li><li>操作系统内核数据没有准备好，立即返回 EWOULDBLOCK 错误码。</li><li>应用程序进程轮询调用，继续向操作系统内核发起 recvfrom 读取数据。</li><li>操作系统内核数据准备好了，从内核缓冲区拷贝到用户空间。</li><li>完成调用，返回成功提示。</li></ol><p>NIO(非阻塞 IO 模型)存在性能问题，即频繁的轮询，导致频繁的系统调用，同样会消耗大量的 CPU 资源。可以考虑 IO 复用模型去解决这个问题。 <strong>IO 多路复用模型</strong>IO 多路复用就是，等到内核数据准备好了，主动通知应用进程再去进行系统调用。 IO 复用模型核心思路：系统给我们提供一类函数（如我们耳濡目染的 select、poll、epoll 函数），它们可以同时监控多个 fd 的操作，任何一个返回内核数据就绪，应用进程再发起 recvfrom 系统调用。<strong>IO 多路复用之 select</strong>应用进程通过调用 select 函数，可以同时监控多个 fd，在 select 函数监控的 fd 中，只要有任何一个数据状态准备就绪了，select 函数就会返回可读状态，这时应用进程再发起 recvfrom 请求去读取数据。</p><figure><img src="https://pic2.zhimg.com/80/v2-27b24bb14dab4045cdca37d741c90608_720w.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>非阻塞 IO 模型（NIO）中，需要 N（N&gt;=1）次轮询系统调用，然而借助 select 的 IO 多路复用模型，只需要发起一次询问就够了,大大优化了性能。 但是呢，select 有几个缺点：</p><ul><li>监听的 IO 最大连接数有限，在 Linux 系统上一般为 1024。</li><li>select 函数返回后，是通过遍历 fdset，找到就绪的描述符 fd。（仅知道有 I/O 事件发生，却不知是哪几个流，所以遍历所有流）</li></ul><p>因为存在连接数限制，所以后来又提出了 poll。与 select 相比，poll 解决了连接数限制问题。但是呢，select 和 poll 一样，还是需要通过遍历文件描述符来获取已经就绪的 socket。如果同时连接的大量客户端，在一时刻可能只有极少处于就绪状态，伴随着监视的描述符数量的增长，效率也会线性下降。 <strong>IO 多路复用之 epoll</strong>为了解决 select/poll 存在的问题，多路复用模型 epoll 诞生，它采用事件驱动来实现，流程图如下：</p><figure><img src="https://pica.zhimg.com/80/v2-aff482c18e66c8d51b9121ced25873e9_720w.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>epoll 先通过 epoll_ctl()来注册一个 fd（文件描述符），一旦基于某个 fd 就绪时，内核会采用回调机制，迅速激活这个 fd，当进程调用 epoll_wait()时便得到通知。这里去掉了遍历文件描述符的坑爹操作，而是采用监听事件回调的机制。这就是 epoll 的亮点。</p><p>**4. Future 实现阻塞等待获取结果的原理？**Future.get()用于异步结果的获取。它是阻塞的，背后原理是什么呢？ 我们可以看下 FutureTask 的类结构图：</p><figure><img src="https://pica.zhimg.com/80/v2-6c5c4a806884ad65363a72c4f127d65a_720w.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>FutureTask 实现了<code>RunnableFuture</code>接口，<code>RunnableFuture</code>继承了<code>Runnable和Future</code>这两个接口， 对于 Runnable，我们太熟悉了， 那么 Future 呢？</p><p>Future 表示一个任务的生命周期，并提供了相应的方法来判断是否已经完成或取消，以及获取任务的结果和取消任务等。</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>public interface Future&lt;V&gt; {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    boolean cancel(boolean mayInterruptIfRunning);</span></span>
<span class="line"><span>    //Future 是否被取消</span></span>
<span class="line"><span>    boolean isCancelled();</span></span>
<span class="line"><span>    //当前 Future 是否已结束</span></span>
<span class="line"><span>    boolean isDone();</span></span>
<span class="line"><span>    //或取Future的结果值。如果当前 Future 还没有结束，当前线程阻塞等待，</span></span>
<span class="line"><span>    V get() throws InterruptedException, ExecutionException;</span></span>
<span class="line"><span>    //获取 Future 的结果值。与 get()一样，不过多了超时时间设置</span></span>
<span class="line"><span>    V get(long timeout, TimeUnit unit)</span></span>
<span class="line"><span>        throws InterruptedException, ExecutionException, TimeoutException;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>FutureTask 就是<code>Runnable和Future</code>的结合体，我们可以把<code>Runnable</code>看作生产者， Future <code>看作</code>消费者。而 FutureTask 是被这两者共享的，生产者运行<code>run</code>方法计算结果，消费者通过<code>get</code>方法获取结果。</p><p>生产者消费者模式，如果生产者数据还没准备的时候，消费者会被阻塞。当生产者数据准备好了以后会唤醒消费者继续执行。我们来看下 FutureTask 内部是如何实现的。</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>FutureTask\`内部维护了任务状态\`state</span></span>
<span class="line"><span>//NEW 新建状态,表示FutureTask新建还没开始执行</span></span>
<span class="line"><span>private static final int NEW          = 0;</span></span>
<span class="line"><span>//完成状态,表示FutureTask</span></span>
<span class="line"><span>private static final int COMPLETING   = 1;</span></span>
<span class="line"><span>//任务正常完成，没有发生异常</span></span>
<span class="line"><span>private static final int NORMAL       = 2;</span></span>
<span class="line"><span>//发生异常</span></span>
<span class="line"><span>private static final int EXCEPTIONAL  = 3;</span></span>
<span class="line"><span>//取消任务</span></span>
<span class="line"><span>private static final int CANCELLED    = 4;</span></span>
<span class="line"><span>//发起中断请求</span></span>
<span class="line"><span>private static final int INTERRUPTING = 5;</span></span>
<span class="line"><span>//中断请求完成</span></span>
<span class="line"><span>private static final int INTERRUPTED  = 6;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>生产者 run 方法：</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> public void run() {</span></span>
<span class="line"><span>        // 如果状态state不是 NEW，或者设置 runner 值失败,直接返回</span></span>
<span class="line"><span>        if (state != NEW ||</span></span>
<span class="line"><span>            !UNSAFE.compareAndSwapObject(this, runnerOffset,</span></span>
<span class="line"><span>                                         null, Thread.currentThread()))</span></span>
<span class="line"><span>            return;</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            Callable&lt;V&gt; c = callable;</span></span>
<span class="line"><span>            if (c != null &amp;&amp; state == NEW) {</span></span>
<span class="line"><span>                V result;</span></span>
<span class="line"><span>                boolean ran;</span></span>
<span class="line"><span>                try {</span></span>
<span class="line"><span>                    //调用callable的call方法，获取结果</span></span>
<span class="line"><span>                    result = c.call();</span></span>
<span class="line"><span>                    //运行成功</span></span>
<span class="line"><span>                    ran = true;</span></span>
<span class="line"><span>                } catch (Throwable ex) {</span></span>
<span class="line"><span>                    result = null;</span></span>
<span class="line"><span>                    //运行不成功</span></span>
<span class="line"><span>                    ran = false;</span></span>
<span class="line"><span>                    //设置异常</span></span>
<span class="line"><span>                    setException(ex);</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span>                //运行成功设置返回结果</span></span>
<span class="line"><span>                if (ran)</span></span>
<span class="line"><span>                    set(result);</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        } finally {</span></span>
<span class="line"><span>            runner = null;</span></span>
<span class="line"><span>            int s = state;</span></span>
<span class="line"><span>            if (s &gt;= INTERRUPTING)</span></span>
<span class="line"><span>                handlePossibleCancellationInterrupt(s);</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>消费者的<code>get</code>方法</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> public V get() throws InterruptedException, ExecutionException {</span></span>
<span class="line"><span>     int s = state;</span></span>
<span class="line"><span>     //如果状态小于等于 COMPLETING，表示 FutureTask 任务还没有完成， 则调用awaitDone让当前线程等待。</span></span>
<span class="line"><span>     if (s &lt;= COMPLETING)</span></span>
<span class="line"><span>         s = awaitDone(false, 0L);</span></span>
<span class="line"><span>     return report(s);</span></span>
<span class="line"><span> }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>awaitDone 做了什么事情呢？</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> private int awaitDone(boolean timed, long nanos)</span></span>
<span class="line"><span>        throws InterruptedException {</span></span>
<span class="line"><span>        final long deadline = timed ? System.nanoTime() + nanos : 0L;</span></span>
<span class="line"><span>        WaitNode q = null;</span></span>
<span class="line"><span>        boolean queued = false;</span></span>
<span class="line"><span>        for (;;) {</span></span>
<span class="line"><span>            // 如果当前线程是中断标记，则  </span></span>
<span class="line"><span>            if (Thread.interrupted()) {</span></span>
<span class="line"><span>                //那么从列表中移除节点 q，并抛出 InterruptedException 异常</span></span>
<span class="line"><span>                removeWaiter(q);</span></span>
<span class="line"><span>                throw new InterruptedException();</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            int s = state;</span></span>
<span class="line"><span>            //如果状态已经完成，表示FutureTask任务已结束</span></span>
<span class="line"><span>            if (s &gt; COMPLETING) {</span></span>
<span class="line"><span>                if (q != null)</span></span>
<span class="line"><span>                    q.thread = null;</span></span>
<span class="line"><span>                //返回</span></span>
<span class="line"><span>                return s;</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>            // 表示还有一些后序操作没有完成，那么当前线程让出执行权</span></span>
<span class="line"><span>            else if (s == COMPLETING) // cannot time out yet</span></span>
<span class="line"><span>                Thread.yield();</span></span>
<span class="line"><span>            //将当前线程阻塞等待</span></span>
<span class="line"><span>            else if (q == null)</span></span>
<span class="line"><span>                q = new WaitNode();</span></span>
<span class="line"><span>            else if (!queued)</span></span>
<span class="line"><span>                queued = UNSAFE.compareAndSwapObject(this, waitersOffset,</span></span>
<span class="line"><span>                                                     q.next = waiters, q);</span></span>
<span class="line"><span>            //timed 为 true 表示需要设置超时                                        </span></span>
<span class="line"><span>            else if (timed) {</span></span>
<span class="line"><span>                nanos = deadline - System.nanoTime();</span></span>
<span class="line"><span>                if (nanos &lt;= 0L) {</span></span>
<span class="line"><span>                    removeWaiter(q);</span></span>
<span class="line"><span>                    return state;</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span>                //让当前线程等待 nanos 时间</span></span>
<span class="line"><span>                LockSupport.parkNanos(this, nanos);</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>            else</span></span>
<span class="line"><span>                LockSupport.park(this);</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然，面试的时候，不一定要讲到源码这么细，只需要讲个大概思路就好啦。</p><p><a href="https://docs.qq.com/doc/DS0NrU3hybHZlRnRq" target="_blank" rel="noopener noreferrer">点击此处可免费领取更多 Java 面试真题</a></p><p>**5. ReentrantLock 和 Synchronized 的区别？Synchronized 原理？**ReentrantLock 和 Synchronized 的区别？</p><ul><li>Synchronized 是依赖于 JVM 实现的，而 ReenTrantLock 是 API 实现的。</li><li>在 Synchronized 优化以前，synchronized 的性能是比 ReenTrantLock 差很多的，但是自从 Synchronized 引入了偏向锁，轻量级锁（自旋锁）后，两者性能就差不多了。</li><li>Synchronized 的使用比较方便简洁，它由编译器去保证锁的加锁和释放。而 ReenTrantLock 需要手工声明来加锁和释放锁，最好在 finally 中声明释放锁。</li><li>ReentrantLock 可以指定是公平锁还是⾮公平锁。⽽synchronized 只能是⾮公平锁。</li><li>ReentrantLock 可响应中断、可轮回，而 Synchronized 是不可以响应中断的，</li></ul><p>**6. 聊聊 AOS？ReentrantLock 的实现原理？**AQS（抽象同步队列）的核心回答要点就是：</p><ul><li>state 状态的维护。</li><li>CLH 队列</li><li>ConditionObject 通知</li><li>模板方法设计模式</li><li>独占与共享模式。</li><li>自定义同步器。</li></ul><p>大家综合 ReentrantLock 的功能，比如可重入，公平锁，非公平锁等，与 AQS 结合一起讲就好啦。**7. 乐观锁和悲观锁， 让你来写你怎么实现？**<strong>悲观锁：</strong> 悲观锁她专一且缺乏安全感了，她的心只属于当前线程，每时每刻都担心着它心爱的数据可能被别的线程修改。因此一个线程拥有（获得）悲观锁后，其他任何线程都不能对数据进行修改啦，只能等待锁被释放才可以执行。</p><figure><img src="https://pica.zhimg.com/80/v2-a792de76f1243b95025f15ccd291f258_720w.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li>SQL 语句 select ...for update 就是悲观锁的一种实现</li><li>还有 Java 的 synchronized 关键字也是悲观锁的一种体现</li></ul><p><strong>乐观锁：<strong>乐观锁的很乐观，它认为数据的变动不会太频繁,操作时一般都不会产生并发问题。因此，它不会上锁，只是在更新数据时，再去判断其他线程在这之前有没有对数据进行过修改。 <strong>实现方式</strong>：乐观锁一般会使用</strong>版本号机制</strong>或 CAS 算法实现。</p><figure><img src="https://pic1.zhimg.com/80/v2-40352ab9b2d0b80cdfeb0a1219642249_720w.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>**8. Paxos 协议了解？工作流程是怎么样的？****8.1 为什么需要 Paxos 算法？**当前我们应用都是集群部署的，要求所有机器状态一致。假设当前有两台机器 A 和 B，A 要把状态修改为 a，B 要把状态修改为 b，那么应该听谁的呢？这时候可以像 2PC 一样，引入一个协调者，谁最先到就听谁的。</p><figure><img src="https://pic2.zhimg.com/80/v2-088138f6df9f4df487784b9e5b4717d3_720w.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>这里有个问题，就是协调者是单节点，如果它挂了呢。因为可以引入多个协调者</p><figure><img src="https://pic2.zhimg.com/80/v2-fb59122f291523dd6e3969ecb5b54ffe_720w.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>但是这么多协调者，应该听谁的呢？ 引入 Paxos 算法解决这个问题，Paxos 算法是一种基于消息传递的分布式一致性算法。<strong>8.2 Paxos 的角色</strong>Paxos 涉及三种角色，分别是 Proposer、Accecptor 、Learners。</p><ul><li>Proposer：它可以提出提案 (Proposal)，提案信息包括<strong>提案编号和提案值</strong>。</li><li>Acceptor：接受接受（accept）提案。一旦接受提案，提案里面的提案值（可以用 V 表示）就被选定了。</li><li>Learner: 哪个提案被选定了, Learner 就学习这个被选择的提案</li></ul><p>一个进程可能是 Proposer,也可能是 Acceptor，也可能是 Learner。<strong>8.2 Paxos 算法推导过程</strong>一致性算法需要<strong>前置条件</strong></p><ul><li>在这些被提出的提案中，只有一个会被选定</li><li>如果没有提案被提出，就不应该有被选定的提案 -当提案被选定后，learner 可以学习被选中的提案</li></ul><p>假设只有一个 Acceptor，只要 Acceptor 接受它收到的第一个提案，就可以保证只有一个 value 会被选定。但是这个 Acceptor 宕机，会导致整个系统不可用。</p><figure><img src="https://pic1.zhimg.com/80/v2-2f729578f3294696270d6436ae7d0a7a_720w.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>如果是是多个 Proposer 和多个 Acceptor，如何选定一个提案呢？</p><figure><img src="https://pica.zhimg.com/80/v2-e15a9bc1d31d19525f7821d036ace0f3_720w.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>我们可以加个约定条件，<strong>假设就叫约束 P1</strong>：<strong>一个 Acceptor 必须接受它收到的第一个提案</strong>。但是这样还是可能会有问题，如果每个 Proposer 分别提出不同的 value（如下图 V1，V2，V3），发给了不同的 Acceptor，最后会导致不同的 value 被选择。</p><figure><img src="https://pica.zhimg.com/80/v2-8495e34b28a063c5be40151aa7a83f5f_720w.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>我们可以给多一个额外的约定<strong>P1a:一个提案被选定，需要被半数以上 Acceptor 接受</strong>。这跟<strong>P1</strong>有点矛盾啦，我们可以使用一个全局的编号来标识每一个 Acceptor 批准的提案，当一个具有某 value 值的提案被<strong>半数以上的 Acceptor</strong>批准后，我们就认为该 value 被选定了。即提案 P= 提案参数 + 提案值，可以记为【M,V】。 现在可以允许多个提案被选定，但必须保证所有被选定的提案都具有相同的 value 值。要不然又会出现不一致啦。因此可以再加个约束 P2： 如果提案 P[M1,V1] 被选定了，那么所有比 M1 编号更高的被选定提案 P，其 value 的值也必须是 V1。 一个提案要被选定，至少要被一个 Acceptor 接受，因此我们可以把 P2 约束改成对 Acceptor 接受的约束 P2a： 如果提案 P[M1,V1] 被接受了，那么所有比 M1 编号更高的，且被 Acceptor 接受的 P，其值也是 V1。 多提案被选择的问题解决了，但是如果是网络不稳定或者宕机的原因，还是会有问题。</p><figure><img src="https://pic2.zhimg.com/80/v2-4041ab6b59a395c7fe498959173dc8cf_720w.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>假设有 5 个 Acceptor。Proposer2 提出 [M1,V1]的提案，Acceptor2~5（半数以上）均接受了该提案，于是对于 Acceptor2~5 和 Proposer2 来讲，它们都认为 V1 被选定。Acceptor1 刚刚从 宕机状态 恢复过来（之前 Acceptor1 没有收到过任何提案），此时 Proposer1 向 Acceptor1 发送了 [M2,V2] 的提案 （V2≠V1 且 M2&gt;M1）。对于 Acceptor1 来讲，这是它收到的 第一个提案。根据 P1（一个 Acceptor 必须接受它收到的 第一个提案），Acceptor1 必须接受该提案。同时 Acceptor1 认为 V2 被选定。 这就出现了两个问题:</p><ul><li>Acceptor1 认为 V2 被选定，Acceptor2~5 和 Proposer2 认为 V1 被选定。出现了不一致。</li><li>V1 被选定了，但是编号更高的被 Acceptor1 接受的提案[M2,V2]的 value 为 V2，且 V2≠V1。这就跟 P2a（如果提案 P[M1,V1] 被接受了，那么所有比 M1 编号更高的，且被 Acceptor 接受的 P，其值也是 V1。）矛盾了。</li></ul><p>我们要对 P2a 约束强化一下得到约束 P2b， 如果 P[M1,V1] 被选定后，任何 Proposer 产生的 P，其值也是 V1。 对于 P2b 中的描述，如何保证任何 Proposer 产生的 P，其值也是 V1 ？只要满足 P2c 即可： 对于任意的 M 和 V,如果提案[M,V]被提出，那么肯定存在一个由半数以上的 Acceptor 组成的集合 S，满足以下两个条件 中的任意一个:</p><ul><li>要么 S 中每个 Acceptor 都没有接受过编号小于 M 的提案。</li><li>要么 S 中所有 Acceptor 批准的所有编号小于 Mn 的提案中，编号最大的那个提案的 value 值为 Vn</li></ul><p><strong>8.3 算法流程****8.3.1. Proposer 生成提案</strong></p><ul><li>Prepare 请求</li><li>Accept 请求</li></ul><p>在 <strong>P2c</strong>约束基础上，如何生成提案呢？ Proposer 选择一个新的提案编号 N，向 Acceptor 集合 S（数目在半数以上）发送请求，要求 S 中的每一个 Acceptor 做出如下响应：</p><ul><li>如果 Acceptor 没有接受过提案，则向 Proposer 保证 不再接受编号小于 N 的提案。</li><li>如果 Acceptor 接受过请求，则向 Proposer 返回 已经接受过的编号小于 N 的编号最大的提案。</li></ul><p>我们将这个请求称为编号为 N 的<strong>Prepare 请求</strong>。</p><ul><li>如果 Proposer 收到半数以上的 Acceptor 响应，则生成编号为 N，value 为 V 的提案 [N,V]，V 为所有响应中编号最大的提案的 value。</li><li>如果 Proposer 收到的响应中没有提案，那么 value 由 Proposer 自己生成，生成后将此提案发给 S，并期望 Acceptor 能接受此提案。</li></ul><p>我们称这个请求为<strong>Accept 请求****8.3.2 Acceptor 接受提案</strong>一个 Acceptor 可能会受到来自 Proposer 的两种请求:Prepare请求和 Accept 请求。Acceptor 什么时候可以响应一个请求呢，它也有个约束：<strong>P1b</strong>： 一个 Acceptor 只要尚未响应过任何编号大于 N 的 Prepare 请求，那么他就可以接受这个编号为 N 的提案。 Acceptor 收到编号为 N 的 Prepare 请求，如果在此之前它已经响应过编号大于 N 的 Prepare 请求。由约束 P1b，该 Acceptor 不会接受这个编号为 N 的提案。因此，Acceptor 会忽略这个请求。 一个 Acceptor 只需记住两点：已接受的编号最大的提案和已响应的请求的最大编号。<strong>8.3.3 Paxos 算法描述</strong>阶段一：</p><ul><li>Proposer 选择一个提案编号 N，然后向半数以上的 Acceptor 发送编号为 N 的 Prepare 请求。</li><li>如果一个 Acceptor 收到一个编号为 N 的 Prepare 请求，且 N 大于该 Acceptor 已经响应过的所有 Prepare 请求的编 号，那么它就会将它已经接受过的编号最大的提案(如果有的话)作为响应反馈给 Proposer，同时该 Acceptor 承诺不再接受任何编号小于 N 的提案。</li></ul><p>阶段二：</p><ul><li>如果 Proposer 收到半数以上 Acceptor 对其发出的编号为 N 的 Prepare 请求的响应，那么它就会发送一个针对 [N,V]提案的 Accept 请求给半数以上的 Acceptor。注意:V就是收到的响应中编号最大的提案的 value，如果响应 中不包含任何提案，那么 V 就由 Proposer 自己决定。</li><li>如果 Acceptor 收到一个针对编号为 N 的提案的 Accept 请求，只要该 Acceptor 没有对编号大于 N 的 Prepare 请求 做出过响应，它就接受该提案。<a href="https://docs.qq.com/doc/DS0NrU3hybHZlRnRq" target="_blank" rel="noopener noreferrer">点击此处可免费领取更多 Java 面试真题</a></li></ul><p><strong>8.3.4 Learner 学习被选定的 value</strong></p><figure><img src="https://pic1.zhimg.com/80/v2-21096268a6dbfefa27c94bf424918ff8_720w.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>**9. B+树是不是有序？B+树和 B-树的主要区别？B+树索引，一次查找过程?**B+树是有序的。<strong>B+树和 B-树的主要区别？</strong></p><ul><li>B-树内部节点是保存数据的;而 B+树内部节点是不保存数据的，只作索引作用，它的叶子节点才保存数据。</li><li>B+树相邻的叶子节点之间是通过链表指针连起来的，B-树却不是。</li><li>查找过程中，B-树在找到具体的数值以后就结束，而 B+树则需要通过索引找到叶子结点中的数据才结束</li><li>B-树中任何一个关键字出现且只出现在一个结点中，而 B+树可以出现多次。</li></ul><p>假设有这么一个 SQL： select * from Temployee where age=32; age 加个一个索引，这条 SQL 是如何在索引上执行的？大家可以举例子画个示意图哈，比如二级索引树，</p><figure><img src="https://pic3.zhimg.com/80/v2-bf28f438add949576f0f396ddfaf2691_720w.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>再画出 id 主键索引，我们先画出聚族索引结构图，如下：</p><figure><img src="https://pic2.zhimg.com/80/v2-23fe12297bb15845be656cfbd9c3600a_720w.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>因此，这条 SQL 查询语句执行大概流程就是酱紫：</p><ul><li>搜索 idx_age 索引树，将磁盘块 1 加载到内存，由于 32&lt;37,搜索左路分支，到磁盘寻址磁盘块 2。</li><li>将磁盘块 2 加载到内存中，在内存继续遍历，找到 age=32 的记录，取得 id = 400.</li><li>拿到 id=400 后，回到 id 主键索引树。</li><li>搜索 id 主键索引树，将磁盘块 1 加载内存，在内存遍历，找到了 400，但是 B+树索引非叶子节点是不保存数据的。索引会继续搜索 400 的右分支，到磁盘寻址磁盘块 3.</li><li>将磁盘块 3 加载内存，在内存遍历，找到 id=400 的记录，拿到 R4 这一行的数据，好的，大功告成。</li></ul><p>**10. TCP 怎么实现拥塞控制？**拥塞控制是作用于网络的，防止过多的数据包注入到网络中，避免出现网络负载过大的情况。它的目标主要是最大化利用网络上瓶颈链路的带宽。 实际上，拥塞控制主要有这几种常用算法</p><ul><li>慢启动</li><li>拥塞避免</li><li>拥塞发生</li><li>快速恢复</li></ul><p><strong>慢启动算法</strong>慢启动算法，表面意思就是，别急慢慢来。它表示 TCP 建立连接完成后，一开始不要发送大量的数据，而是先探测一下网络的拥塞程度。由小到大逐渐增加拥塞窗口的大小，如果没有出现丢包，* *每收到一个 ACK，就将拥塞窗口 cwnd 大小就加 1（单位是 MSS）**。<strong>每轮次</strong>发送窗口增加一倍，呈指数增长，如果出现丢包，拥塞窗口就减半，进入拥塞避免阶段。</p><ul><li>TCP 连接完成，初始化 cwnd = 1，表明可以传一个 MSS 单位大小的数据。</li><li>每当收到一个 ACK，cwnd 就加一;</li><li>每当过了一个 RTT，cwnd 就增加一倍; 呈指数让升</li></ul><figure><img src="https://pica.zhimg.com/80/v2-5b56712d09a5b70b21549a9c43387b46_720w.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>为了防止 cwnd 增长过大引起网络拥塞，还需设置一个<strong>慢启动阀值 ssthresh</strong>（slow start threshold）状态变量。当 cwnd 到达该阀值后，就好像水管被关小了水龙头一样，减少拥塞状态。即当<strong>cwnd &gt;ssthresh</strong>时，进入了<strong>拥塞避免</strong>算法。<strong>拥塞避免算法</strong> 一般来说，慢启动阀值 ssthresh 是 65535 字节，cwnd 到达<strong>慢启动阀值</strong>后</p><ul><li>每收到一个 ACK 时，cwnd = cwnd + 1/cwnd</li><li>当每过一个 RTT 时，cwnd = cwnd + 1</li></ul><p>显然这是一个线性上升的算法，避免过快导致网络拥塞问题。<a href="https://docs.qq.com/doc/DS0NrU3hybHZlRnRq" target="_blank" rel="noopener noreferrer">点击此处可免费领取更多 Java 面试真题</a></p><figure><img src="https://pic1.zhimg.com/80/v2-11a6b503f6b5202e052b133940dd68a6_720w.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>拥塞发生</strong>当网络拥塞发生<strong>丢包</strong>时，会有两种情况：</p><ul><li>RTO 超时重传</li><li>快速重传</li></ul><p>如果是发生了<strong>RTO 超时重传</strong>，就会使用拥塞发生算法</p><ul><li>慢启动阀值 sshthresh = cwnd /2</li><li>cwnd 重置为 1</li><li>进入新的慢启动过程</li></ul><figure><img src="https://pic3.zhimg.com/80/v2-24149a802490ca8504e3a2006fe14f2f_720w.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>这真的是<strong>辛辛苦苦几十年，一朝回到解放前</strong>。其实还有更好的处理方式，就是<strong>快速重传</strong>。发送方收到 3 个连续重复的 ACK 时，就会快速地重传，不必等待<strong>RTO 超时</strong>再重传。</p><figure><img src="https://pic1.zhimg.com/80/v2-b611b1ab48a5d04cb163eb73f424da45_720w.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>慢启动阀值 ssthresh 和 cwnd 变化如下：</p><ul><li>拥塞窗口大小 cwnd = cwnd/2</li><li>慢启动阀值 ssthresh = cwnd</li><li>进入快速恢复算法</li></ul><p><strong>快速恢复</strong>快速重传和快速恢复算法一般同时使用。快速恢复算法认为，还有 3 个重复 ACK 收到，说明网络也没那么糟糕，所以没有必要像 RTO 超时那么强烈。 正如前面所说，进入快速恢复之前，cwnd 和 sshthresh 已被更新： - cwnd = cwnd /2 - sshthresh = cwnd 然后，真正的快速算法如下：</p><ul><li>cwnd = sshthresh + 3</li><li>重传重复的那几个 ACK（即丢失的那几个数据包）</li><li>如果再收到重复的 ACK，那么 cwnd = cwnd +1</li><li>如果收到新数据的 ACK 后, cwnd = sshthresh。因为收到新数据的 ACK，表明恢复过程已经结束，可以再次进入了拥塞避免的算法了。</li></ul><figure><img src="https://pic3.zhimg.com/80/v2-0e187e1a5374416dd9aed9fecd949507_720w.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>11. JVM 调优****11.1 一般什么时候考虑 JVM 调优呢？</strong></p><ul><li>Heap 内存（老年代）持续上涨达到设置的最大内存值；</li><li>Full GC 次数频繁；</li><li>GC 停顿时间过长（超过 1 秒）；</li><li>应用出现 OutOfMemory 等内存异常；</li><li>应用中有使用本地缓存且占用大量内存空间；</li><li>系统吞吐量与响应性能不高或下降。</li></ul><p><strong>11.2 JVM 调优的目标</strong></p><ul><li>延迟：GC 低停顿和 GC 低频率；</li><li>低内存占用；</li><li>高吞吐量;</li></ul><p><strong>11.3 JVM 调优量化目标</strong></p><ul><li>Heap 内存使用率 &lt;= 70%;</li><li>Old generation 内存使用率&lt;= 70%;</li><li>avgpause &lt;= 1 秒;</li><li>Full gc 次数 0 或 avg pause interval &gt;= 24 小时 ;</li></ul><p><strong>11.4 JVM 调优的步骤</strong></p><ul><li>分析 GC 日志及 dump 文件，判断是否需要优化，确定瓶颈问题点；</li><li>确定 JVM 调优量化目标；</li><li>确定 JVM 调优参数（根据历史 JVM 参数来调整）；</li><li>依次调优内存、延迟、吞吐量等指标；</li><li>对比观察调优前后的差异；</li><li>不断的分析和调整，直到找到合适的 JVM 参数配置；</li><li>找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪。</li></ul><p><strong>11.5 常见的 JVM 参数****堆栈配置相关</strong>-Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:MaxPermSize=16m -XX:NewRatio=4 -XX: SurvivorRatio=4 -XX:MaxTenuringThreshold=0</p><ul><li>-Xmx3550m：最大堆大小为 3550m。</li><li>-Xms3550m：设置初始堆大小为 3550m。</li><li>-Xmn2g：设置年轻代大小为 2g。</li><li>-Xss128k：每个线程的堆栈大小为 128k。</li><li>-XX:MaxPermSize： 设置持久代大小为 16m</li><li>-XX:NewRatio=4: 设置年轻代（包括 Eden 和两个 Survivor 区）与年老代的比值（除去持久代）。</li><li>-XX:SurvivorRatio=4：设置年轻代中 Eden 区与 Survivor 区的大小比值。设置为 4，则两个 Survivor 区与一个 Eden 区的比值为 2: 4，一个 Survivor 区占整个年轻代的 1/6</li><li>-XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为 0 的话，则年轻代对象不经过 Survivor 区，直接进入年老代。</li></ul><p><strong>垃圾收集器相关</strong>-XX:+UseParallelGC -XX:ParallelGCThreads=20 -XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction=5 -XX:+UseCMSCompactAtFullCollection： -XX:+UseConcMarkSweepGC</p><ul><li>-XX:+UseParallelGC：选择垃圾收集器为并行收集器。</li><li>-XX:ParallelGCThreads=20：配置并行收集器的线程数</li><li>-XX:+UseConcMarkSweepGC：设置年老代为并发收集。</li><li>-XX:CMSFullGCsBeforeCompaction：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次 GC 以后对内存空间进行压缩、整理。</li><li>-XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除碎片</li><li>-XX:+UseConcMarkSweepGC 使用 CMS 垃圾收集器</li></ul><p><strong>辅助信息</strong>-XX:+PrintGC -XX: +PrintGCDetails<a href="https://docs.qq.com/doc/DS0NrU3hybHZlRnRq" target="_blank" rel="noopener noreferrer">点击此处可免费领取更多 Java 面试真题</a></p><p><strong>11.6 常用调优策略</strong></p><ul><li>选择合适的垃圾回收器</li><li>调整内存大小(垃圾收集频率非常频繁,如果是内存太小，可适当调整内存大小)</li><li>调整内存区域大小比率（某一个区域的 GC 频繁，其他都正常。）</li><li>调整对象升老年代的年龄（老年代频繁 GC，每次回收的对象很多。）</li><li>调整大对象的标准(老年代频繁 GC，每次回收的对象很多,而且单个对象的体积都比较大。)</li><li>调整 GC 的触发时机(CMS，G1 经常 Full GC，程序卡顿严重。)</li><li>调整 JVM 本地内存大小(GC 的次数、时间和回收的对象都正常，堆内存空间充足，但是报 OOM)</li></ul><p><strong>12. 数据库分库分表的缺点是啥？</strong></p><ol><li>事务问题，已经不可以用本地事务了，需要用分布式事务。</li><li>跨节点 Join 的问题：解决这一问题可以分两次查询实现</li><li>跨节点的 count,order by,group by 以及聚合函数问题：分别在各个节点上得到结果后在应用程序端进行合并。</li><li>ID 问题：数据库被切分后，不能再依赖数据库自身的主键生成机制啦，最简单可以考虑 UUID</li><li>跨分片的排序分页问题（后台加大 pagesize 处理？）</li></ol><p>**13. 分布式事务如何解决？TCC 了解？**<strong>分布式事务：</strong> 就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。简单来说，分布式事务指的就是分布式系统中的事务，它的存在就是为了保证不同数据库节点的数据一致性。 聊到分布式事务，需要知道这两个基本理论哈。</p><ul><li>CAP 理论</li><li>BASE 理论</li></ul><p><strong>CAP 理论</strong></p><ul><li>一致性(C：Consistency)：一致性是指数据在多个副本之间能否保持一致的特性。例如一个数据在某个分区节点更新之后，在其他分区节点读出来的数据也是更新之后的数据。</li><li>可用性(A：Availability) ：可用性是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。这里的重点是&quot; 有限时间内&quot;和&quot;返回结果&quot;。</li><li>分区容错性（P:Partition tolerance）:分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务。</li></ul><p><strong>BASE 理论</strong>它是对 CAP 中 AP 的一个扩展，对于我们的业务系统，我们考虑牺牲一致性来换取系统的可用性和分区容错性。BASE 是 Basically Available，Soft state,和 Eventually consistent 三个短语的缩写。</p><ul><li>Basically Available(基本可用)：通过支持局部故障而不是系统全局故障来实现的。如将用户分区在 5 个数据库服务器上，一个用户数据库的故障只影响这台特定主机那 20% 的用户，其他用户不受影响。</li><li>Soft State(软状态):状态可以有一段时间不同步</li><li>Eventually Consistent(最终一致):最终数据是一致的就可以了，而不是时时保持强一致。</li></ul><p>分布式事务的几种解决方案：</p><ul><li>2PC(二阶段提交)方案、3PC</li><li>TCC（Try、Confirm、Cancel）</li><li>本地消息表</li><li>最大努力通知</li><li>seata 事务</li></ul><p>**TCC（补偿机制）**TCC 采用了补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。TCC（Try-Confirm-Cancel）包括三段流程：</p><ul><li>try 阶段：尝试去执行，完成所有业务的一致性检查，预留必须的业务资源。</li><li>Confirm 阶段：该阶段对业务进行确认提交，不做任何检查，因为 try 阶段已经检查过了，默认 Confirm 阶段是不会出错的。</li><li>Cancel 阶段：若业务执行失败，则进入该阶段，它会释放 try 阶段占用的所有业务资源，并回滚 Confirm 阶段执行的所有操作。</li></ul><p>下面再拿用户下单购买礼物作为例子来模拟 TCC 实现分布式事务的过程： 假设用户 A 余额为 100 金币，拥有的礼物为 5 朵。A 花了 10 个金币，下订单，购买 10 朵玫瑰。余额、订单、礼物都在不同数据库。<strong>TCC 的 Try 阶段：</strong></p><ul><li>生成一条订单记录，订单状态为待确认。</li><li>将用户 A 的账户金币中余额更新为 90，冻结金币为 10（预留业务资源）</li><li>将用户的礼物数量为 5，预增加数量为 10。</li><li>Try 成功之后，便进入 Confirm 阶段</li><li>Try 过程发生任何异常，均进入 Cancel 阶段</li></ul><figure><img src="https://pic3.zhimg.com/80/v2-01c52c546f620d066139812e2a42bedf_720w.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>TCC 的 Confirm 阶段：</strong></p><ul><li>订单状态更新为已支付</li><li>更新用户余额为 90，可冻结为 0</li><li>用户礼物数量更新为 15，预增加为 0</li><li>Confirm 过程发生任何异常，均进入 Cancel 阶段</li><li>Confirm 过程执行成功，则该事务结束</li></ul><figure><img src="https://pic3.zhimg.com/80/v2-6af237478c54d86d94cf67b95aedc8c3_720w.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>TCC 的 Cancel 阶段：</strong></p><ul><li>修改订单状态为已取消</li><li>更新用户余额回 100</li><li>更新用户礼物数量为 5</li></ul><figure><img src="https://pic1.zhimg.com/80/v2-b50eb4ada2d31e1cecbd351ad206ed3c_720w.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li>TCC 的优点是可以自定义数据库操作的粒度，降低了锁冲突，可以提升性能</li><li>TCC 的缺点是应用侵入性强，需要根据网络、系统故障等不同失败原因实现不同的回滚策略，实现难度大，一般借助 TCC 开源框架，ByteTCC，TCC-transaction，Himly。</li></ul><h2 id="_14-rocketmq-如何保证消息的准确性和安全性" tabindex="-1"><a class="header-anchor" href="#_14-rocketmq-如何保证消息的准确性和安全性"><span>14， RocketMQ 如何保证消息的准确性和安全性？</span></a></h2><p>我个人理解的话，这道题换汤不换药，就是为如何保证 RocketMQ 不丢消息，保证不重复消费，消息有序性，消息堆积的处理。</p><p>消息不丢失的话，即从生产者、存储端、消费端去考虑</p><p><a href="https://docs.qq.com/doc/DS0NrU3hybHZlRnRq" target="_blank" rel="noopener noreferrer">点击此处可免费领取更多 Java 面试真题</a></p><h2 id="_15-三个数求和" tabindex="-1"><a class="header-anchor" href="#_15-三个数求和"><span>15. 三个数求和</span></a></h2><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组</p><p>实例 1：</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>输入：nums = [-1,0,1,2,-1,-4]</span></span>
<span class="line"><span>输出：[[-1,-1,2],[-1,0,1]]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>实例 2：</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>输入：nums = [0]</span></span>
<span class="line"><span>输出：[]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>思路：</strong></p><p>这道题可以先给数组排序，接着用左右双指针。</p><p><strong>完整代码如下：</strong></p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>class Solution {</span></span>
<span class="line"><span>    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;();</span></span>
<span class="line"><span>        if(nums==null||nums.length&lt;3){ //为空或者元素个数小于3，直接返回</span></span>
<span class="line"><span>            return result;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        Arrays.sort(nums); //排序</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        for(int i=0;i&lt;nums.length-2;i++){ //遍历到倒数第三个，因为是三个数总和</span></span>
<span class="line"><span>            if(nums[i]&gt;0){ //大于0可以直接跳出循环了</span></span>
<span class="line"><span>                break;</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            if(i&gt;0&amp;&amp;nums[i]==nums[i-1]){ //过滤重复</span></span>
<span class="line"><span>                continue;</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            int left = i+1;  //左指针</span></span>
<span class="line"><span>            int right = nums.length-1; //右指针</span></span>
<span class="line"><span>            int target = - nums[i];  //目标总和，是第i个的取反，也就是a+b+c=0,则b+c=-a即可</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            while(left&lt;right){</span></span>
<span class="line"><span>                if(nums[left]+ nums[right]==target){ //b+c=-a,满足a+b+c=0</span></span>
<span class="line"><span>                   result.add(Arrays.asList(nums[i],nums[left],nums[right]));</span></span>
<span class="line"><span>                   left++;  //左指针右移</span></span>
<span class="line"><span>                   right--;  //右指针左移</span></span>
<span class="line"><span>                   while(left&lt;right&amp;&amp;nums[left]==nums[left-1]) left++; //继续左边过滤重复</span></span>
<span class="line"><span>                   while(left&lt;right&amp;&amp;nums[right]==nums[right+1]) right--; //继续右边过滤重复</span></span>
<span class="line"><span>                }else if(nums[left]+ nums[right]&lt;target){</span></span>
<span class="line"><span>                   left++; //小于目标值，需要右移，因为排好序是从小到大的</span></span>
<span class="line"><span>                }else{</span></span>
<span class="line"><span>                  right--;  </span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>            return result;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,169)]))}const d=i(e,[["render",p],["__file","腾讯云后端总结的面试15问.html.vue"]]),o=JSON.parse('{"path":"/dev/%E8%85%BE%E8%AE%AF%E4%BA%91%E5%90%8E%E7%AB%AF%E6%80%BB%E7%BB%93%E7%9A%84%E9%9D%A2%E8%AF%9515%E9%97%AE.html","title":"腾讯云后端总结的面试15问","lang":"zh-CN","frontmatter":{"author":"xlc520","title":"腾讯云后端总结的面试15问","excerpt":null,"description":"腾讯云后端总结的面试15问","date":"2022-03-22T00:00:00.000Z","category":"Java","tag":"Java","article":true,"timeline":true,"icon":"type","head":[["meta",{"property":"og:url","content":"https://blog.ciberviler.top/dev/%E8%85%BE%E8%AE%AF%E4%BA%91%E5%90%8E%E7%AB%AF%E6%80%BB%E7%BB%93%E7%9A%84%E9%9D%A2%E8%AF%9515%E9%97%AE.html"}],["meta",{"property":"og:site_name","content":"StudyNote - 丰富的知识笔记库"}],["meta",{"property":"og:title","content":"腾讯云后端总结的面试15问"}],["meta",{"property":"og:description","content":"腾讯云后端总结的面试15问"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://pic1.zhimg.com/80/v2-4612838075ea362fe4c9d3fb28514af2_720w.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-27T13:32:36.000Z"}],["meta",{"property":"article:author","content":"xlc520"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:published_time","content":"2022-03-22T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-27T13:32:36.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"腾讯云后端总结的面试15问\\",\\"image\\":[\\"https://pic1.zhimg.com/80/v2-4612838075ea362fe4c9d3fb28514af2_720w.png\\",\\"https://pic2.zhimg.com/80/v2-7005e4d083f4183c8cbc4e06e46a65bd_720w.png\\",\\"https://pic3.zhimg.com/80/v2-a255e00d0c3c64807c7fa3de5f90f8e5_720w.png\\",\\"https://pic1.zhimg.com/80/v2-cc942a7fa9dcc344ba8ab3825474f1e6_720w.png\\",\\"https://pic3.zhimg.com/80/v2-5ecab3b6edb0cd59756be08c75113d1f_720w.png\\",\\"https://pic2.zhimg.com/80/v2-27b24bb14dab4045cdca37d741c90608_720w.png\\",\\"https://pica.zhimg.com/80/v2-aff482c18e66c8d51b9121ced25873e9_720w.png\\",\\"https://pica.zhimg.com/80/v2-6c5c4a806884ad65363a72c4f127d65a_720w.png\\",\\"https://pica.zhimg.com/80/v2-a792de76f1243b95025f15ccd291f258_720w.png\\",\\"https://pic1.zhimg.com/80/v2-40352ab9b2d0b80cdfeb0a1219642249_720w.png\\",\\"https://pic2.zhimg.com/80/v2-088138f6df9f4df487784b9e5b4717d3_720w.png\\",\\"https://pic2.zhimg.com/80/v2-fb59122f291523dd6e3969ecb5b54ffe_720w.png\\",\\"https://pic1.zhimg.com/80/v2-2f729578f3294696270d6436ae7d0a7a_720w.png\\",\\"https://pica.zhimg.com/80/v2-e15a9bc1d31d19525f7821d036ace0f3_720w.png\\",\\"https://pica.zhimg.com/80/v2-8495e34b28a063c5be40151aa7a83f5f_720w.png\\",\\"https://pic2.zhimg.com/80/v2-4041ab6b59a395c7fe498959173dc8cf_720w.png\\",\\"https://pic1.zhimg.com/80/v2-21096268a6dbfefa27c94bf424918ff8_720w.png\\",\\"https://pic3.zhimg.com/80/v2-bf28f438add949576f0f396ddfaf2691_720w.png\\",\\"https://pic2.zhimg.com/80/v2-23fe12297bb15845be656cfbd9c3600a_720w.png\\",\\"https://pica.zhimg.com/80/v2-5b56712d09a5b70b21549a9c43387b46_720w.png\\",\\"https://pic1.zhimg.com/80/v2-11a6b503f6b5202e052b133940dd68a6_720w.png\\",\\"https://pic3.zhimg.com/80/v2-24149a802490ca8504e3a2006fe14f2f_720w.png\\",\\"https://pic1.zhimg.com/80/v2-b611b1ab48a5d04cb163eb73f424da45_720w.png\\",\\"https://pic3.zhimg.com/80/v2-0e187e1a5374416dd9aed9fecd949507_720w.png\\",\\"https://pic3.zhimg.com/80/v2-01c52c546f620d066139812e2a42bedf_720w.png\\",\\"https://pic3.zhimg.com/80/v2-6af237478c54d86d94cf67b95aedc8c3_720w.png\\",\\"https://pic1.zhimg.com/80/v2-b50eb4ada2d31e1cecbd351ad206ed3c_720w.png\\"],\\"datePublished\\":\\"2022-03-22T00:00:00.000Z\\",\\"dateModified\\":\\"2024-04-27T13:32:36.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xlc520\\"}]}"]]},"headers":[{"level":2,"title":"14， RocketMQ 如何保证消息的准确性和安全性？","slug":"_14-rocketmq-如何保证消息的准确性和安全性","link":"#_14-rocketmq-如何保证消息的准确性和安全性","children":[]},{"level":2,"title":"15. 三个数求和","slug":"_15-三个数求和","link":"#_15-三个数求和","children":[]}],"git":{"createdTime":1648110167000,"updatedTime":1714224756000,"contributors":[{"name":"xlc520","email":"2215400217@qq.com","commits":2},{"name":"xlc","email":"2215400217@qq.com","commits":1}]},"readingTime":{"minutes":32.72,"words":9815},"filePathRelative":"dev/腾讯云后端总结的面试15问.md","localizedDate":"2022年3月22日","excerpt":"\\n<ol>\\n<li>聊聊项目，好的设计，好的代码</li>\\n<li>谈谈什么是零拷贝？</li>\\n<li>一共有几种 IO 模型？NIO 和多路复用的区别？</li>\\n<li>Future 实现阻塞等待获取结果的原理？</li>\\n<li>ReentrantLock 和 Synchronized 的区别？Synchronized 的原理？</li>\\n<li>聊聊 AOS？ReentrantLock 的实现原理？</li>\\n<li>乐观锁和悲观锁， 让你来写你怎么实现？</li>\\n<li>Paxos 协议了解？工作流程是怎么样的？</li>\\n<li>B+树聊一下？B+树是不是有序？B+树和 B-树的主要区别？</li>\\n<li>TCP 的拥塞机制</li>\\n<li>工作中有过 JVM 实践嘛</li>\\n<li>数据库分库分表的缺点是啥？</li>\\n<li>分布式事务如何解决？TCC 了解？</li>\\n<li>RocketMQ 如何保证消息的准确性和安全性？</li>\\n<li>算法题：三个数求和</li>\\n</ol>"}');export{d as comp,o as data};
